<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.5.56">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
    <meta name="dcterms.date" content="2024-08-22">

    <title>Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
      /* CSS for syntax highlighting */
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
        }
      pre.numberSource { margin-left: 3em;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      /* CSS for citations */
      div.csl-bib-body { }
      div.csl-entry {
        clear: both;
        margin-bottom: 0em;
      }
      .hanging-indent div.csl-entry {
        margin-left:2em;
        text-indent:-2em;
      }
      div.csl-left-margin {
        min-width:2em;
        float:left;
      }
      div.csl-right-inline {
        margin-left:2em;
        padding-left:1em;
      }
      div.csl-indent {
        margin-left: 2em;
      }    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
     <script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>   <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> 
      <meta name="citation_title" content="Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations">
<meta name="citation_author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="citation_publication_date" content="2024-08-22">
<meta name="citation_cover_date" content="2024-08-22">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-08-22">
<meta name="citation_language" content="en">
<meta name="citation_reference" content="citation_title=Gaussian Markov Random Fields: Theory and Applications;,citation_author=Havard Rue;,citation_author=Leonhard Held;,citation_publication_date=2005-02-18;,citation_cover_date=2005-02-18;,citation_year=2005;,citation_language=en;">
<meta name="citation_reference" content="citation_title=Spatial Analysis;,citation_author=John T. Kent;,citation_author=Kanti V. Mardia;,citation_publication_date=2022-05-31;,citation_cover_date=2022-05-31;,citation_year=2022;,citation_language=en;">
<meta name="citation_reference" content="citation_title=On edge correction of conditional and intrinsic autoregressions;,citation_author=D Mondal;,citation_publication_date=2018-06-01;,citation_cover_date=2018-06-01;,citation_year=2018;,citation_fulltext_html_url=https://doi.org/10.1093/biomet/asy014;,citation_issue=2;,citation_doi=10.1093/biomet/asy014;,citation_volume=105;,citation_journal_title=Biometrika;">
<meta name="citation_reference" content="citation_title=First-order intrinsic autoregressions and the de wijs process;,citation_author=Julian Besag;,citation_author=Debashis Mondal;,citation_publication_date=2005-12-01;,citation_cover_date=2005-12-01;,citation_year=2005;,citation_fulltext_html_url=https://doi.org/10.1093/biomet/92.4.909;,citation_issue=4;,citation_doi=10.1093/biomet/92.4.909;,citation_volume=92;,citation_journal_title=Biometrika;">
<meta name="citation_reference" content="citation_title=Approximate Bayesian inference for latent Gaussian models by using integrated nested Laplace approximations;,citation_author=Håvard Rue;,citation_author=Sara Martino;,citation_author=Nicolas Chopin;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_fulltext_html_url=https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-9868.2008.00700.x;,citation_issue=2;,citation_doi=10.1111/j.1467-9868.2008.00700.x;,citation_volume=71;,citation_language=en;,citation_journal_title=Journal of the Royal Statistical Society: Series B (Statistical Methodology);">
<meta name="citation_reference" content="citation_title=Fonctions de répartition à n dimensions et leurs marges;,citation_author=M. Sklar;,citation_publication_date=1959;,citation_cover_date=1959;,citation_year=1959;,citation_fulltext_html_url=https://hal.science/hal-04094463;,citation_issue=3;,citation_volume=VIII;,citation_journal_title=Annales de l’ISUP;">
<meta name="citation_reference" content="citation_title=Multivariate models and multivariate dependence concepts;,citation_author=Harry Joe;,citation_publication_date=1997-05-01;,citation_cover_date=1997-05-01;,citation_year=1997;">
<meta name="citation_reference" content="citation_title=An introduction to copulas;,citation_author=Roger B. Nelsen;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_language=en;,citation_series_title=Springer series in statistics;">
<meta name="citation_reference" content="citation_title=An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach;,citation_author=Finn Lindgren;,citation_author=Håvard Rue;,citation_author=Johan Lindström;,citation_publication_date=2011;,citation_cover_date=2011;,citation_year=2011;,citation_fulltext_html_url=https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-9868.2011.00777.x;,citation_issue=4;,citation_doi=10.1111/j.1467-9868.2011.00777.x;,citation_volume=73;,citation_language=en;,citation_journal_title=Journal of the Royal Statistical Society: Series B (Statistical Methodology);">
<meta name="citation_reference" content="citation_title=Matrix Analysis for Scientists and Engineers | SIAM Publications Library;,citation_fulltext_html_url=https://epubs.siam.org/doi/book/10.1137/1.9780898717907;,citation_language=en;">
<meta name="citation_reference" content="citation_title=Toeplitz and circulant matrices: A review;,citation_author=Robert M. Gray;,citation_publication_date=2006-01-30;,citation_cover_date=2006-01-30;,citation_year=2006;,citation_fulltext_html_url=https://www.nowpublishers.com/article/Details/CIT-006;,citation_issue=3;,citation_doi=10.1561/0100000006;,citation_volume=2;,citation_language=en-US;,citation_journal_title=Foundations and Trends® in Communications and Information Theory;">
<meta name="citation_reference" content="citation_title=Bayesian modelling of inseparable space-time variation in disease risk;,citation_author=Leonhard Knorr-Held;,citation_publication_date=2000;,citation_cover_date=2000;,citation_year=2000;,citation_issue=17-18;,citation_doi=10.1002/1097-0258(20000915/30)19:17/18&amp;amp;amp;lt;2555::AID-SIM587&amp;gt;3.0.CO;2-#;,citation_issn=1097-0258;,citation_volume=19;,citation_language=en-US;,citation_journal_title=Statistics in Medicine;">
</head>

  <body class="quarto-notebook">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> Article Notebook</h6>

            <a href="./index.qmd" class="btn btn-primary quarto-download-embed" download="index.qmd">Download Source</a>
          </div>

     <header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Author</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author"><a href="bggj.is">Brynjólfur Gauti Guðrúnar Jónsson</a> <a href="mailto:brynjolfur@hi.is" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        University of Iceland
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">August 22, 2024</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-formulation" id="toc-problem-formulation" class="nav-link" data-scroll-target="#problem-formulation">Problem Formulation</a></li>
  <li><a href="#review" id="toc-review" class="nav-link" data-scroll-target="#review">Review</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#gaussian-copula-density-computation" id="toc-gaussian-copula-density-computation" class="nav-link" data-scroll-target="#gaussian-copula-density-computation">Gaussian Copula Density Computation</a></li>
  <li><a href="#precision-matrix-structure" id="toc-precision-matrix-structure" class="nav-link" data-scroll-target="#precision-matrix-structure">Precision Matrix Structure</a></li>
  <li><a href="#computation-process" id="toc-computation-process" class="nav-link" data-scroll-target="#computation-process">Computation Process</a>
  <ul class="collapse">
  <li><a href="#step-1-eigendecomposition-of-mathbfq_rho" id="toc-step-1-eigendecomposition-of-mathbfq_rho" class="nav-link" data-scroll-target="#step-1-eigendecomposition-of-mathbfq_rho">Step 1: Eigendecomposition of <span class="math inline">\(\mathbf{Q}_{\rho}\)</span></a></li>
  <li><a href="#step-2-computation-of-marginal-standard-deviations" id="toc-step-2-computation-of-marginal-standard-deviations" class="nav-link" data-scroll-target="#step-2-computation-of-marginal-standard-deviations">Step 2: Computation of Marginal Standard Deviations</a></li>
  <li><a href="#step-3-scaling-the-eigendecomposition" id="toc-step-3-scaling-the-eigendecomposition" class="nav-link" data-scroll-target="#step-3-scaling-the-eigendecomposition">Step 3: Scaling the Eigendecomposition</a></li>
  <li><a href="#step-4-efficient-computation-of-log-density" id="toc-step-4-efficient-computation-of-log-density" class="nav-link" data-scroll-target="#step-4-efficient-computation-of-log-density">Step 4: Efficient Computation of Log-Density</a></li>
  </ul></li>
  <li><a href="#circulant-and-folded-circulant-approximations" id="toc-circulant-and-folded-circulant-approximations" class="nav-link" data-scroll-target="#circulant-and-folded-circulant-approximations">Circulant and Folded Circulant Approximations</a>
  <ul class="collapse">
  <li><a href="#circulant-matrices" id="toc-circulant-matrices" class="nav-link" data-scroll-target="#circulant-matrices">Circulant Matrices</a></li>
  <li><a href="#block-circulant-matrices" id="toc-block-circulant-matrices" class="nav-link" data-scroll-target="#block-circulant-matrices">Block Circulant Matrices</a></li>
  <li><a href="#approximations-for-q_rho" id="toc-approximations-for-q_rho" class="nav-link" data-scroll-target="#approximations-for-q_rho">Approximations for <span class="math inline">\(Q_{\rho}\)</span></a></li>
  <li><a href="#extension-to-the-full-q-matrix" id="toc-extension-to-the-full-q-matrix" class="nav-link" data-scroll-target="#extension-to-the-full-q-matrix">Extension to the Full Q Matrix</a></li>
  </ul></li>
  <li><a href="#computation-with-circulant-approximation" id="toc-computation-with-circulant-approximation" class="nav-link" data-scroll-target="#computation-with-circulant-approximation">Computation with Circulant Approximation</a>
  <ul class="collapse">
  <li><a href="#construct-the-base-matrix" id="toc-construct-the-base-matrix" class="nav-link" data-scroll-target="#construct-the-base-matrix">1. Construct the Base Matrix</a></li>
  <li><a href="#compute-initial-eigenvalues" id="toc-compute-initial-eigenvalues" class="nav-link" data-scroll-target="#compute-initial-eigenvalues">2. Compute Initial Eigenvalues</a></li>
  <li><a href="#compute-marginal-variance-and-rescale-eigenvalues" id="toc-compute-marginal-variance-and-rescale-eigenvalues" class="nav-link" data-scroll-target="#compute-marginal-variance-and-rescale-eigenvalues">3. Compute Marginal Variance and Rescale Eigenvalues</a></li>
  <li><a href="#compute-log-determinant" id="toc-compute-log-determinant" class="nav-link" data-scroll-target="#compute-log-determinant">4. Compute Log-Determinant</a></li>
  <li><a href="#compute-quadratic-form" id="toc-compute-quadratic-form" class="nav-link" data-scroll-target="#compute-quadratic-form">5. Compute Quadratic Form</a></li>
  <li><a href="#compute-the-log-density" id="toc-compute-the-log-density" class="nav-link" data-scroll-target="#compute-the-log-density">6. Compute the Log-Density</a></li>
  </ul></li>
  <li><a href="#computation-with-folded-circulant-approximation" id="toc-computation-with-folded-circulant-approximation" class="nav-link" data-scroll-target="#computation-with-folded-circulant-approximation">Computation with Folded Circulant Approximation</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#computational-efficiency" id="toc-computational-efficiency" class="nav-link" data-scroll-target="#computational-efficiency">Computational Efficiency</a></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix">Appendix</a>
  <ul class="collapse">
  <li><a href="#cholesky-methods" id="toc-cholesky-methods" class="nav-link" data-scroll-target="#cholesky-methods">Cholesky Methods</a>
  <ul class="collapse">
  <li><a href="#unscaled-precision-matrix" id="toc-unscaled-precision-matrix" class="nav-link" data-scroll-target="#unscaled-precision-matrix">Unscaled Precision Matrix</a></li>
  <li><a href="#scaled-precision-matrix" id="toc-scaled-precision-matrix" class="nav-link" data-scroll-target="#scaled-precision-matrix">Scaled Precision Matrix</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      

       <div class="cell-container"><div class="cell-decorator"><pre>In [1]:</pre></div><div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(glue)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<section id="problem-formulation" class="level2">
<h2 class="anchored" data-anchor-id="problem-formulation">Problem Formulation</h2>
<p>Consider a spatial field on a regular <span class="math inline">\(n_1 \times n_2\)</span> grid. Our objective is to compute the Gaussian copula density efficiently for this field. This computation involves:</p>
<ol type="1">
<li>Specifying an <span class="math inline">\(n_1 n_2 \times n_1 n_2\)</span> precision matrix <span class="math inline">\(\mathbf{Q}\)</span> that represents the spatial dependence structure.</li>
<li>Ensuring the implied covariance matrix <span class="math inline">\(\mathbf{\Sigma} = \mathbf{Q}^{-1}\)</span> has unit diagonal elements.</li>
<li>Computing the log determinant, <span class="math inline">\(\log |\mathbf Q|\)</span>, and the quadratic form <span class="math inline">\(z^T \mathbf Q z\)</span> where <span class="math inline">\(z_i = \Phi^{-1}(f_i(y_i))\)</span></li>
</ol>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>Gaussian Markov Random Fields (GMRFs) and copulas are two powerful statistical tools, each offering unique strengths in modeling complex data structures. GMRFs excel in capturing spatial and temporal dependencies, particularly in fields such as environmental science, epidemiology, and image analysis <span class="citation" data-cites="rue2005 knorr-heldBayesianModellingInseparable2000 rue2009">(<a href="#ref-rue2005" role="doc-biblioref">Havard Rue and Held 2005</a>; <a href="#ref-knorr-heldBayesianModellingInseparable2000" role="doc-biblioref">Knorr-Held 2000</a>; <a href="#ref-rue2009" role="doc-biblioref">Håvard Rue, Martino, and Chopin 2009</a>)</span>. Their ability to represent local dependencies through sparse precision matrices makes them computationally attractive for high-dimensional problems. Copulas, on the other hand, provide a flexible framework for modeling multivariate dependencies, allowing separate specification of marginal distributions and their joint behavior <span class="citation" data-cites="sklar1959 joe1997 nelsen2006">(<a href="#ref-sklar1959" role="doc-biblioref">Sklar 1959</a>; <a href="#ref-joe1997" role="doc-biblioref">Joe 1997</a>; <a href="#ref-nelsen2006" role="doc-biblioref">Nelsen 2006</a>)</span>.</p>
<p>The Gaussian copula, in particular, has gained popularity due to its interpretability and connection to the multivariate normal distribution. However, combining GMRFs with copulas has historically been computationally challenging, limiting their joint application to smaller datasets or simpler models.</p>
<p>Let <span class="math inline">\(\mathbf{X} = (X_1, X_2, \ldots, X_n)\)</span> be a multivariate random vector with marginal distribution functions <span class="math inline">\(F_i\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>. The joint distribution function of <span class="math inline">\(\mathbf{X}\)</span> can be written as:</p>
<p><span class="math display">\[
F_{\mathbf{X}}(\mathbf{x}) = C(F_1(x_1), F_2(x_2), \ldots, F_n(x_n)),
\]</span></p>
<p>where <span class="math inline">\(C\)</span> is the Gaussian copula defined by the GMRF precision matrix <span class="math inline">\(\mathbf{Q}\)</span>. The Gaussian copula <span class="math inline">\(C\)</span> is given by:</p>
<p><span class="math display">\[
C(u_1, u_2, \ldots, u_n) = \Phi_\mathbf{Q}(\Phi^{-1}(u_1), \Phi^{-1}(u_2), \ldots, \Phi^{-1}(u_n)),
\]</span></p>
<p>where <span class="math inline">\(\Phi_\mathbf{Q}\)</span> is the joint cumulative distribution function of a multivariate normal distribution with mean vector <span class="math inline">\(\mathbf{0}\)</span> and precision matrix <span class="math inline">\(\mathbf{Q}\)</span>, and <span class="math inline">\(\Phi^{-1}\)</span> is the inverse of the standard normal cumulative distribution function.</p>
<p>A critical requirement for the precision matrix <span class="math inline">\(\mathbf{Q}\)</span> governing the GMRF copula <span class="math inline">\(C\)</span> is that <span class="math inline">\(\mathbf{\Sigma} = \mathbf{Q}^{-1}\)</span> should have a unit diagonal, i.e.&nbsp;the marginal variance is equal to one everywhere. This ensures it operates on the same scale as the transformed data, <span class="math inline">\(\Phi^{-1}(u_i)\)</span>. However, this can be challenging as GMRFs are typically defined in terms of precision matrices that often imply non-unit marginal variances.</p>
<p>This paper presents a novel algorithm that bridges the gap between GMRFs and copulas, allowing for fast and efficient computation of Gaussian copula densities using GMRF precision structures. Our method focuses on creating a Matérn-like precision matrix <span class="math inline">\(\mathbf{Q}\)</span> with unit marginal variance and efficiently computing the multivariate Gaussian copula density of <span class="math inline">\(\mathbf{Z} = \Phi^{-1}(\mathbf{u})\)</span>, where <span class="math inline">\(u_i \sim \text{Uniform}(0, 1)\)</span>, <span class="math inline">\(i = 1, \dots, n\)</span>.</p>
<p>The key innovation lies in leveraging the special structure of the precision matrix:</p>
<p><span class="math display">\[
\mathbf{Q} = \mathbf{Q}_{\rho_1} \otimes \mathbf{I_{n_2}} + \mathbf{I_{n_1}} \otimes \mathbf{Q}_{\rho_2},
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Q}_\rho\)</span> is the precision matrix of a standardized one-dimensional AR(1) process with correlation <span class="math inline">\(\rho\)</span> and <span class="math inline">\(\otimes\)</span> denotes the Kronecker product. By employing efficient eigendecomposition techniques, our method avoids explicit formation and inversion of the large precision matrix <span class="math inline">\(\mathbf{Q}\)</span>, making it particularly suitable for high-dimensional spatial data. In addition to the exact method, we show how the precision matrix can be approximated by a folded circulant matrix wich gives a large speed-up while preserving suitable boundary conditions <span class="citation" data-cites="kent2022 mondal2018 besag2005">(<a href="#ref-kent2022" role="doc-biblioref">Kent and Mardia 2022</a>; <a href="#ref-mondal2018" role="doc-biblioref">Mondal 2018</a>; <a href="#ref-besag2005" role="doc-biblioref">Besag and Mondal 2005</a>)</span>.</p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="gaussian-copula-density-computation" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-copula-density-computation">Gaussian Copula Density Computation</h2>
<p>The Gaussian copula density for a random vector <span class="math inline">\(\mathbf{U} = (U_1, ..., U_n)\)</span> with <span class="math inline">\(U_i \sim \text{Uniform}(0,1)\)</span> is given by:</p>
<p><span class="math display">\[
c(\mathbf{u}) = |\mathbf{Q}|^{1/2} \exp\left(-\frac{1}{2}\mathbf{z}^T(\mathbf{Q} - \mathbf{I})\mathbf{z}\right)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{z} = (z_1, ..., z_n)\)</span> with <span class="math inline">\(z_i = \Phi^{-1}(u_i)\)</span>, <span class="math inline">\(\mathbf{Q}\)</span> is the precision matrix, and <span class="math inline">\(\mathbf{I}\)</span> is the identity matrix.</p>
<p>The log-density can be expressed as:</p>
<p><span class="math display">\[
\log c(\mathbf{u}) = \frac{1}{2}\log|\mathbf{Q}| - \frac{1}{2}\mathbf{z}^T\mathbf{Q}\mathbf{z} + \frac{1}{2}\mathbf{z}^T\mathbf{z}
\]</span></p>
<p>Our goal is to efficiently compute this log-density for large spatial fields.</p>
</section>
<section id="precision-matrix-structure" class="level2">
<h2 class="anchored" data-anchor-id="precision-matrix-structure">Precision Matrix Structure</h2>
<p>Similarly to the GMRF approximation to a Matérn process in <span class="citation" data-cites="lindgren2011">(<a href="#ref-lindgren2011" role="doc-biblioref">Lindgren, Rue, and Lindström 2011</a>)</span>, we define the precision matrix <span class="math inline">\(\mathbf{Q}\)</span> as:</p>
<p><span class="math display">\[
\mathbf{Q} = (\mathbf{Q}_{\rho_1} \otimes \mathbf{I_{n_2}} + \mathbf{I_{n_1}} \otimes \mathbf{Q}_{\rho_2})^{(\nu + 1)}, \quad \nu \in \{0, 1, 2\}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Q}_\rho\)</span> is the precision matrix of a one-dimensional AR(1) process with correlation <span class="math inline">\(\rho\)</span>:</p>
<p><span class="math display">\[
\mathbf{Q}_\rho = \frac{1}{1-\rho^2}
\begin{bmatrix}
1 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}.
\]</span></p>
<p>The matrix, <span class="math inline">\(\mathbf Q\)</span>, is then scaled so that its inverse, <span class="math inline">\(\mathbf \Sigma = \mathbf Q^{-1}\)</span> is a correlation matrix, i.e.&nbsp;<span class="math inline">\(\mathbf \Sigma_{ii} = 1\)</span>.</p>
</section>
<section id="computation-process" class="level2">
<h2 class="anchored" data-anchor-id="computation-process">Computation Process</h2>
<section id="step-1-eigendecomposition-of-mathbfq_rho" class="level3">
<h3 class="anchored" data-anchor-id="step-1-eigendecomposition-of-mathbfq_rho">Step 1: Eigendecomposition of <span class="math inline">\(\mathbf{Q}_{\rho}\)</span></h3>
<p>We first compute the eigendecomposition of both <span class="math inline">\(\mathbf{Q}_{\rho}\)</span>$:</p>
<p><span class="math display">\[
\mathbf{Q}_{\rho} = \mathbf{V_{\rho}}\mathbf{\Lambda_\rho}\mathbf{V_\rho}^T
\]</span></p>
<p>where <span class="math inline">\(\mathbf{V_\rho}\)</span> is the matrix of eigenvectors and <span class="math inline">\(\mathbf{\Lambda_\rho}\)</span> is the diagonal matrix of eigenvalues. Then, because of how <span class="math inline">\(Q\)</span> is defined, its eigendecomposition is (see for example <span class="citation" data-cites="matrixa">(<a href="#ref-matrixa" role="doc-biblioref"><span>“Matrix Analysis for Scientists and Engineers | SIAM Publications Library,”</span> n.d.</a>)</span>):</p>
<p><span class="math display">\[
\mathbf{Q} = (\mathbf{V_{\rho_1}} \otimes \mathbf{V_{\rho_2}})(\mathbf{\Lambda_{\rho_1}} \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{\Lambda_{\rho_2}})^{(\nu + 1)}(\mathbf{V_{\rho_1}} \otimes \mathbf{V_{\rho_2}})^T.
\]</span></p>
<p>We don’t work with the full eigendecomposition, but rather utilize the fact that the eigenvalues of <span class="math inline">\(\mathbf Q\)</span> are <span class="math inline">\(\left\{\lambda_{\rho_1}\right\}_i + \left\{\lambda_{\rho_2}\right\}_j\)</span> and their corresponding eigenvectors are <span class="math inline">\(\left\{\mathbf{v}_{\rho_1}\right\}_i \otimes \left\{\mathbf{v}_{\rho_2}\right\}_j\)</span> to iterate over each value and vector pair to compute the density without forming the larger matrix.</p>
</section>
<section id="step-2-computation-of-marginal-standard-deviations" class="level3">
<h3 class="anchored" data-anchor-id="step-2-computation-of-marginal-standard-deviations">Step 2: Computation of Marginal Standard Deviations</h3>
<p>In order to scale <span class="math inline">\(\mathbf Q\)</span> so that its inverse is a correlation matrix, we first calculate <span class="math inline">\(\sigma_i = \sqrt\Sigma_{ii}\)</span>, <span class="math inline">\(i = 1, \dots, n_1n_2\)</span>. We then use these marginal standard deviations to scale the eigenvectors and values. The inverse of <span class="math inline">\(Q\)</span> is given by:</p>
<p><span class="math display">\[
\boldsymbol \Sigma = \mathbf Q^{-1} = (VAV^T)^{-1} = VA^{-1}V
\]</span></p>
<p>The diagonal elements, <span class="math inline">\(\boldsymbol \Sigma_{ii}\)</span>, are given by:</p>
<p><span class="math display">\[
\Sigma_{ii} = \sum_{k=1}^{n} v_{ik} \frac{1}{\lambda_k} (v^T)_{ki} = \sum_{k=1}^{n} v_{ik} \frac{1}{\lambda_k} v_{ik} = \sum_{k=1}^{n} v_{ik}^2 \frac{1}{\lambda_k}
\]</span></p>
<p>This means that the <span class="math inline">\(i\)</span>’th marginal variance, <span class="math inline">\(\sigma_i^2\)</span>, is a weighted sum of the reciprocals of the eigenvalues of <span class="math inline">\(\mathbf Q\)</span> where the weights are the squares of the <span class="math inline">\(i\)</span>’th value in each eigenvector. This means that we can calculate the marginal standard deviations by iterating over the eigenvalues and -vectors of <span class="math inline">\(Q_{\rho_1}\)</span> and <span class="math inline">\(Q_{\rho_2}\)</span> and cumulating their values according to the formula above, then taking the element-wise square roots.</p>
</section>
<section id="step-3-scaling-the-eigendecomposition" class="level3">
<h3 class="anchored" data-anchor-id="step-3-scaling-the-eigendecomposition">Step 3: Scaling the Eigendecomposition</h3>
<p>To scale the eigendecomposition of <span class="math inline">\(\mathbf{Q}\)</span> using the marginal standard deviations, we define a diagonal matrix <span class="math inline">\(\mathbf{D}\)</span>, where <span class="math inline">\(D_{ii} = \sigma_i\)</span> and scale the precision matrix as:</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{\widetilde  Q} &amp;= \mathbf{D}\mathbf{Q}^{\nu+1}\mathbf{D} \\
&amp;= \mathbf{D}\mathbf{V}\mathbf{\Lambda}^{\nu+1}\mathbf{V}^T\mathbf{D} \\
&amp;= \mathbf{\widetilde V}\mathbf{\widetilde\Lambda}\mathbf{\widetilde V}^T.
\end{aligned}
\]</span></p>
<p>In practice, we don’t scale the whole eigendecomposition. Instead, we rescale each value/vector pair individually as we iterate over the eigenvectors and values of <span class="math inline">\(Q_{\rho_1}\)</span> and <span class="math inline">\(Q_{\rho_2}\)</span> to create the corresponding values and vectors for the larger matrix.</p>
</section>
<section id="step-4-efficient-computation-of-log-density" class="level3">
<h3 class="anchored" data-anchor-id="step-4-efficient-computation-of-log-density">Step 4: Efficient Computation of Log-Density</h3>
<p>Using this scaled eigendecomposition, we efficiently compute:</p>
<ol type="1">
<li><p>Log-determinant: <span class="math inline">\(\log|\mathbf{\widetilde Q}| = \sum_{i,j} \log(\widetilde\lambda_{ij})\)</span>, where <span class="math inline">\(\widetilde\lambda_{ij}\)</span> is <span class="math inline">\(\left( \left\{\lambda_{\rho_1}\right\}_i + \left\{\lambda_{\rho_2}\right\}_j \right)^{\nu+1}\)</span> after rescaling with marginal standard deviations.</p></li>
<li><p>Quadratic form: <span class="math inline">\(\mathbf{z}^T\mathbf{\widetilde Q}\mathbf{z} = \sum_{i,j} (\widetilde\lambda_{ij}) y_{ij}^2\)</span>, where <span class="math inline">\(y_{ij} = \left(\left\{\mathbf{v}_{\rho_1}\right\}_i \otimes \left\{\mathbf{v}_{\rho_2}\right\}_j\right)^T\mathbf{z}\)</span>.</p></li>
</ol>
<p>This approach allows us to calculate the density of the spatial copula by calculating and iterating over the spectral decomposition of the smaller matrices, avoiding the formation of <span class="math inline">\(\mathbf Q\)</span> alltogether.</p>
</section>
</section>
<section id="circulant-and-folded-circulant-approximations" class="level2">
<h2 class="anchored" data-anchor-id="circulant-and-folded-circulant-approximations">Circulant and Folded Circulant Approximations</h2>
<p>While the eigendecomposition method provides an exact solution, it can be computationally expensive for very large spatial fields. To address this, we introduce circulant and folded circulant approximations that offer computational efficiency and speed.</p>
<section id="circulant-matrices" class="level3">
<h3 class="anchored" data-anchor-id="circulant-matrices">Circulant Matrices</h3>
<p>A circulant matrix <span class="math inline">\(C\)</span> is a special kind of matrix where each row is a cyclic shift of the row above it. It can be fully specified by its first row or column, called the base <span class="math inline">\(c\)</span>:</p>
<p><span class="math display">\[
C = \begin{pmatrix}
c_0 &amp; c_1 &amp; c_2 &amp; \cdots &amp; c_{n-1} \\
c_{n-1} &amp; c_0 &amp; c_1 &amp; \cdots &amp; c_{n-2} \\
c_{n-2} &amp; c_{n-1} &amp; c_0 &amp; \cdots &amp; c_{n-3} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
c_1 &amp; c_2 &amp; c_3 &amp; \cdots &amp; c_0
\end{pmatrix} = (c_{j-i \mod n})
\]</span></p>
<p>The base vector <span class="math inline">\(c\)</span> completely determines the circulant matrix and plays a crucial role in efficient computations. In particular:</p>
<ol type="1">
<li><p>The eigenvalues of <span class="math inline">\(C\)</span> are given by the Discrete Fourier Transform (DFT) of <span class="math inline">\(c\)</span>: <span class="math display">\[
\lambda = \text{DFT}(c)
\]</span></p></li>
<li><p>Matrix-vector multiplication can be performed using the FFT: <span class="math display">\[
Cv = \text{DFT}(\text{DFT}(c) \odot \text{IDFT}(v))
\]</span></p></li>
<li><p>When <span class="math inline">\(C\)</span> is non singular, then the inverse is circulant and thus determined by its base:</p></li>
</ol>
<p><span class="math display">\[
\frac1n \text{IDFT}(\text{DFT}(c)^{-1}).
\]</span></p>
<p>These properties allow for much faster computations than for general matrices. For more reading on applications of circulant matrices to GMRFs see <span class="citation" data-cites="rue2005 gray2006">(<a href="#ref-rue2005" role="doc-biblioref">Havard Rue and Held 2005</a>; <a href="#ref-gray2006" role="doc-biblioref">Gray 2006</a>)</span>.</p>
</section>
<section id="block-circulant-matrices" class="level3">
<h3 class="anchored" data-anchor-id="block-circulant-matrices">Block Circulant Matrices</h3>
<p>For two-dimensional spatial fields, we use block circulant matrices with circulant blocks (BCCB). An <span class="math inline">\(Nn \times Nn\)</span> matrix C is block circulant if it has the form:</p>
<p><span class="math display">\[
C = \begin{pmatrix}
C_0 &amp; C_1 &amp; C_2 &amp; \cdots &amp; C_{N-1} \\
C_{N-1} &amp; C_0 &amp; C_1 &amp; \cdots &amp; C_{N-2} \\
C_{N-2} &amp; C_{N-1} &amp; C_0 &amp; \cdots &amp; C_{N-3} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
C_1 &amp; C_2 &amp; C_3 &amp; \cdots &amp; C_0
\end{pmatrix} = (C_{j-i \mod N})
\]</span></p>
<p>where each <span class="math inline">\(C_i\)</span> is itself a circulant <span class="math inline">\(n \times n\)</span> matrix.</p>
<p>For a BCCB matrix, we define a base matrix <span class="math inline">\(\mathbf c\)</span>, which is an <span class="math inline">\(n \times N\)</span> matrix where each column is the base vector of the corresponding circulant block. This base matrix <span class="math inline">\(\mathbf c\)</span> completely determines the BCCB matrix and is central to efficient computations:</p>
<ol type="1">
<li><p>The eigenvalues of <span class="math inline">\(C\)</span> are given by the 2D DFT of <span class="math inline">\(\mathbf c\)</span>.</p></li>
<li><p>Matrix-vector multiplication can be performed using the 2D FFT.</p></li>
<li><p>When <span class="math inline">\(C\)</span> is non singular, then the inverse is also a BCCB matrix and thus determined by its base matrix.</p></li>
</ol>
</section>
<section id="approximations-for-q_rho" class="level3">
<h3 class="anchored" data-anchor-id="approximations-for-q_rho">Approximations for <span class="math inline">\(Q_{\rho}\)</span></h3>
<p>Let <span class="math inline">\(Q_{\rho}\)</span> be the precision matrix of a one-dimensional AR(1) process with correlation <span class="math inline">\(\rho\)</span>. The exact form of <span class="math inline">\(Q_{\rho}\)</span> is:</p>
<p><span class="math display">\[
\mathbf{Q}_\rho = \frac{1}{1-\rho^2}
\begin{bmatrix}
1 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}
\]</span></p>
<section id="circulant-approximation" class="level4">
<h4 class="anchored" data-anchor-id="circulant-approximation">Circulant Approximation</h4>
<p>The circulant approximation to <span class="math inline">\(Q_\rho\)</span>, denoted as <span class="math inline">\(\mathbf{Q}_\rho^{(circ)}\)</span>, is:</p>
<p><span class="math display">\[
\mathbf{Q}_\rho^{(circ)} = \frac{1}{1-\rho^2}
\begin{bmatrix}
1+\rho^2 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; -\rho \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
-\rho &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho &amp; 1+\rho^2
\end{bmatrix}
\]</span></p>
<p>This approximation treats the first and last observations as neighbors, effectively wrapping the data around a circle.</p>
</section>
<section id="folded-circulant-approximation" class="level4">
<h4 class="anchored" data-anchor-id="folded-circulant-approximation">Folded Circulant Approximation</h4>
<p>The folded circulant approximation, <span class="math inline">\(\mathbf{Q}_\rho^{(fold)}\)</span>, is based on a reflected version of the data <span class="citation" data-cites="kent2022 mondal2018 besag2005">(<a href="#ref-kent2022" role="doc-biblioref">Kent and Mardia 2022</a>; <a href="#ref-mondal2018" role="doc-biblioref">Mondal 2018</a>; <a href="#ref-besag2005" role="doc-biblioref">Besag and Mondal 2005</a>)</span>. We double the data by reflecting it, giving us the data <span class="math inline">\(x_1,  \dots, x_n, x_n, \dots, x_1\)</span>. We then model this doubled data with a <span class="math inline">\(2n \times 2n\)</span> circulant matrix. If written out as an <span class="math inline">\(n \times n\)</span> matrix, it takes the form:</p>
<p><span class="math display">\[
\mathbf{Q}_\rho^{(fold)} = \frac{1}{1-\rho^2}
\begin{bmatrix}
1-\rho+\rho^2 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho &amp; 1-\rho+\rho^2
\end{bmatrix}
\]</span></p>
<p>This approximation modifies the first and last diagonal elements to account for the reflection of the data. As <span class="math inline">\(x_1\)</span> now is the first and last data point, then we avoid the circular dependence from the regular circulant approximation.</p>
</section>
</section>
<section id="extension-to-the-full-q-matrix" class="level3">
<h3 class="anchored" data-anchor-id="extension-to-the-full-q-matrix">Extension to the Full Q Matrix</h3>
<p>For a two-dimensional spatial field on an <span class="math inline">\(n_1 \times n_2\)</span> grid, we construct the full precision matrix Q using a Kronecker sum:</p>
<p><span class="math display">\[
\mathbf{Q} = \left( \mathbf{Q}_{\rho_1} \otimes \mathbf{I_{n_2}} + \mathbf{I_{n_1}} \otimes \mathbf{Q}_{\rho_2} \right)^{(\nu + 1)}, \quad \nu \in \{0, 1, 2\}
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, <span class="math inline">\(I_n\)</span> is the <span class="math inline">\(n \times n\)</span> identity matrix, and <span class="math inline">\(\nu\)</span> is a smoothness parameter.</p>
<p>When we approximate <span class="math inline">\(Q_\rho\)</span> with a circulant matrix, this Kronecker sum results in a block-circulant matrix with circulant blocks (BCCB). To see this, let’s consider the case where <span class="math inline">\(\nu = 0\)</span> for simplicity:</p>
<p><span class="math display">\[
\mathbf{Q} = \mathbf{Q}_{\rho_1} \otimes \mathbf{I_{n_2}} + \mathbf{I_{n_1}} \otimes \mathbf{Q}_{\rho_2}
\]</span></p>
<p>Now, let the two AR(1) matrices be approximated by circulant matrices, <span class="math inline">\(\mathbf C_\rho\)</span>, with base vectors <span class="math inline">\(\mathbf c_\rho = \frac{1}{1-\rho^2}\left[1+\rho^2, -\rho, 0, ..., 0, -\rho \right]\)</span>. Then:</p>
<p><span class="math display">\[
\mathbf{Q}_{\rho_1} \approx \mathbf{C_{\rho_1}} = \frac{1}{1-\rho_1^2}
\begin{bmatrix}
1+\rho_1^2 &amp; -\rho_1 &amp; 0 &amp; \cdots &amp; 0 &amp; -\rho_1 \\
-\rho_1 &amp; 1+\rho_1^2 &amp; -\rho_1 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho_1 &amp; 1+\rho_1^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
-\rho_1 &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho_1 &amp; 1+\rho_1^2
\end{bmatrix},
\]</span></p>
<p>and <span class="math inline">\(C_{\rho_2}\)</span> is defined similarly. The Kronecker product <span class="math inline">\(\mathbf C_{\rho_1} \otimes \mathbf I_{n_2}\)</span> results in a block matrix where each block is a scalar multiple of <span class="math inline">\(I_{n_2}\)</span>:</p>
<p><span class="math display">\[
\mathbf{C_{\rho_1}} \otimes \mathbf{I_{n_2}} = \frac{1}{1-\rho_1^2}
\begin{pmatrix}
(1+\rho_1^2)\mathbf{I_{n_2}} &amp; -\rho_1\mathbf{I_{n_2}} &amp; \dots &amp; \cdots &amp; -\rho_1\mathbf{I_{n_2}} \\
-\rho_1\mathbf{I_{n_2}} &amp; (1+\rho_1^2)\mathbf{I_{n_2}} &amp; -\rho_1 \mathbf{I_{n_2}} &amp; \cdots &amp; \vdots  \\
\vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \\
\vdots &amp; \ddots &amp; -\rho_1\mathbf{I_{n_2}} &amp; (1+\rho_1^2)\mathbf{I_{n_2}} &amp; -\rho_1 \mathbf{I_{n_2}}  \\
-\rho_1\mathbf{I_{n_2}} &amp; \dots &amp; \cdots &amp; -\rho_1 \mathbf{I_{n_2}} &amp; (1+\rho_1^2)\mathbf{I_{n_2}}
\end{pmatrix}.
\]</span></p>
<p>Similarly, <span class="math inline">\(\mathbf I_{n_1} \otimes \mathbf C_{\rho_2}\)</span> results in a block diagonal matrix where each block is a copy of <span class="math inline">\(C_{\rho_2}\)</span>:</p>
<p><span class="math display">\[
\mathbf{I_{n_1}} \otimes \mathbf{C_{\rho_2}} =
\begin{pmatrix}
\mathbf{C_{\rho_2}} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \\
\mathbf{0} &amp; \mathbf{C_{\rho_2}} &amp; \cdots &amp; \mathbf{0} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{C_{\rho_2}}
\end{pmatrix}.
\]</span></p>
<p>The sum of these two matrices is a block-circulant matrix with circulant blocks:</p>
<p><span class="math display">\[
\mathbf{Q} \approx \mathbf C_{\rho_1} \otimes \mathbf I_{n_2} + \mathbf I_{n_1} \otimes \mathbf C_{\rho_2} =
\begin{pmatrix}
\mathbf{B}_0 &amp; \mathbf{B}_1 &amp; \cdots &amp; \mathbf{B}_{n_1-1} \\
\mathbf{B}_{n_1-1} &amp; \mathbf{B}_0 &amp; \cdots &amp; \mathbf{B}_{n_1-2} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mathbf{B}_1 &amp; \mathbf{B}_2 &amp; \cdots &amp; \mathbf{B}_0
\end{pmatrix}
\]</span></p>
<p>where each <span class="math inline">\(\mathbf{B_i}\)</span> is a circulant matrix. Specifically, each <span class="math inline">\(\mathbf B_i = \mathbf 0\)</span> except for</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{B_0} &amp;= \frac{(1+\rho_1^2)}{(1 - \rho_1^2)}\mathbf{I_{n_2}} + \mathbf C_{\rho_2}, \quad \text{and} \\
\mathbf{B_1} &amp;= \mathbf{B_{n_1 - 1}} = \frac{-\rho_1}{(1 - \rho_1^2)}\mathbf{I_{n_2}}.
\end{aligned}
\]</span></p>
<p>This BCCB structure allows us to use 2D FFT for efficient computations. The base matrix <span class="math inline">\(\mathbf c\)</span> for this BCCB structure is:</p>
<p><span class="math display">\[
\mathbf{c} = \begin{bmatrix}
\frac{(1+\rho_1^2)}{(1 - \rho_1^2)} + \frac{(1+\rho_2^2)}{(1 - \rho_2^2)} &amp; \frac{-\rho_1}{(1 - \rho_1^2)} &amp; 0 &amp; \cdots  &amp; \frac{-\rho_1}{(1 - \rho_1^2)} \\
\frac{-\rho_2}{(1 - \rho_2^2)} &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;  \vdots \\
\frac{-\rho_2}{(1 - \rho_2^2)} &amp; 0 &amp; 0 &amp; \cdots  &amp; 0
\end{bmatrix}
\]</span></p>
<p>This base matrix <span class="math inline">\(c\)</span> captures the structure of the precision matrix <span class="math inline">\(\mathbf Q\)</span> and allows for efficient computation of eigenvalues using the 2D Fast Fourier Transform (FFT), enabling rapid calculation of the log-determinant and quadratic forms needed for the Gaussian copula density.</p>
</section>
</section>
<section id="computation-with-circulant-approximation" class="level2">
<h2 class="anchored" data-anchor-id="computation-with-circulant-approximation">Computation with Circulant Approximation</h2>
<p>When using the circulant approximation, we leverage the efficient computation properties of block circulant matrices with circulant blocks (BCCB). This approach significantly reduces the computational complexity, especially for large spatial fields. Here’s the step-by-step process:</p>
<section id="construct-the-base-matrix" class="level3">
<h3 class="anchored" data-anchor-id="construct-the-base-matrix">1. Construct the Base Matrix</h3>
<p>First, we construct the base matrix <span class="math inline">\(\mathbf c\)</span> for our BCCB approximation of <span class="math inline">\(\mathbf Q\)</span>. For an <span class="math inline">\(n_1 \times n_2\)</span> grid, <span class="math inline">\(\mathbf c\)</span> is an <span class="math inline">\(n_2 \times n_1\)</span> matrix:</p>
<p><span class="math display">\[
\mathbf{c} = \begin{bmatrix}
\frac{(1+\rho_1^2)}{(1 - \rho_1^2)} + \frac{(1+\rho_2^2)}{(1 - \rho_2^2)} &amp; \frac{-\rho_1}{(1 - \rho_1^2)} &amp; 0 &amp; \cdots  &amp; \frac{-\rho_1}{(1 - \rho_1^2)} \\
\frac{-\rho_2}{(1 - \rho_2^2)} &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;  \vdots \\
\frac{-\rho_2}{(1 - \rho_2^2)} &amp; 0 &amp; 0 &amp; \cdots  &amp; 0
\end{bmatrix}
\]</span></p>
<p>This base matrix encapsulates the structure of our Matérn-like precision matrix.</p>
</section>
<section id="compute-initial-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="compute-initial-eigenvalues">2. Compute Initial Eigenvalues</h3>
<p>We compute the initial eigenvalues of <span class="math inline">\(\mathbf Q\)</span> using the 2D Fast Fourier Transform (FFT) of <span class="math inline">\(\mathbf c\)</span>:</p>
<p><span class="math display">\[
\boldsymbol{\Lambda} = \text{FFT2}(\mathbf{c})^{\nu+1}
\]</span></p>
<p>where ν is the smoothness parameter.</p>
</section>
<section id="compute-marginal-variance-and-rescale-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="compute-marginal-variance-and-rescale-eigenvalues">3. Compute Marginal Variance and Rescale Eigenvalues</h3>
<p>An important property of Block Circulant with Circulant Blocks (BCCB) matrices is that the inverse of a BCCB matrix is also a BCCB matrix, and the marginal variance is the first element in its first circulant block. We use this to efficiently compute the marginal variance and rescale the eigenvalues:</p>
<ol type="a">
<li>Compute the element-wise inverse of <span class="math inline">\(\boldsymbol{\Lambda}\)</span>: <span class="math inline">\(\mathbf{\Lambda^{inv}} = 1 / \boldsymbol{\Lambda}\)</span></li>
<li>Compute the base of <span class="math inline">\(\mathbf Q^{-1}\)</span> using inverse 2D FFT: <span class="math inline">\(\mathbf{c_{inv}} = \text{IFFT2}(\mathbf{{\Lambda^{inv}}})\)</span></li>
<li>The marginal variance is given by the first element of <span class="math inline">\(\mathbf{c^{inv}}\)</span>: <span class="math inline">\(\sigma^2 = \mathbf{c^{inv}}_{(0,0)}\)</span></li>
<li>Rescale the eigenvalues: <span class="math inline">\(\boldsymbol{\widetilde \Lambda} = \sigma^2 \boldsymbol{\Lambda}\)</span></li>
</ol>
<p>This process ensures that the resulting precision matrix will have unit marginal variances, as required for the Gaussian copula.</p>
</section>
<section id="compute-log-determinant" class="level3">
<h3 class="anchored" data-anchor-id="compute-log-determinant">4. Compute Log-Determinant</h3>
<p>The log-determinant of the scaled <span class="math inline">\(\mathbf{\widetilde Q}\)</span> can be efficiently calculated as the sum of the logarithms of the scaled eigenvalues:</p>
<p><span class="math display">\[
\log|\mathbf{Q}| = \sum_{i,j} \log(\widetilde \Lambda_{ij})
\]</span></p>
</section>
<section id="compute-quadratic-form" class="level3">
<h3 class="anchored" data-anchor-id="compute-quadratic-form">5. Compute Quadratic Form</h3>
<p>To compute the quadratic form <span class="math inline">\(\mathbf{z}^T\mathbf{Q}\mathbf{z}\)</span>, we use the following steps:</p>
<ol type="a">
<li>Compute the 2D FFT of z: <span class="math inline">\(\mathbf{\hat{z}} = \text{FFT2}(\mathbf{z})\)</span></li>
<li>Multiply element-wise with the scaled eigenvalues: <span class="math inline">\(\mathbf{\hat{y}} = \boldsymbol{\widetilde \Lambda} \odot \mathbf{\hat{z}}\)</span></li>
<li>Compute the inverse 2D FFT: <span class="math inline">\(\mathbf{y} = \text{IFFT2}(\mathbf{\hat{y}})\)</span></li>
<li>Compute the dot product: <span class="math inline">\(\mathbf{z}^T\mathbf{Q}\mathbf{z} = \mathbf{z}^T\mathbf{y}\)</span></li>
</ol>
</section>
<section id="compute-the-log-density" class="level3">
<h3 class="anchored" data-anchor-id="compute-the-log-density">6. Compute the Log-Density</h3>
<p>Finally, we can compute the log-density of the Gaussian copula:</p>
<p><span class="math display">\[
\log c(\mathbf{u}) = \frac{1}{2}\log|\mathbf{Q}| - \frac{1}{2}\mathbf{z}^T\mathbf{Q}\mathbf{z} + \frac{1}{2}\mathbf{z}^T\mathbf{z}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{z} = \Phi^{-1}(\mathbf{u})\)</span>.</p>
</section>
</section>
<section id="computation-with-folded-circulant-approximation" class="level2">
<h2 class="anchored" data-anchor-id="computation-with-folded-circulant-approximation">Computation with Folded Circulant Approximation</h2>
<p>The folded circulant approximation offers an alternative approach that can provide better accuracy near the edges of the spatial field. This method is based on the idea of reflecting the data along each coordinate axis, effectively doubling the size of the field. Other than that, the algorithmic implementation is the same except that the circulant approximation matrices to <span class="math inline">\(\mathbf Q_{\rho}\)</span> are now <span class="math inline">\(2n \times 2n\)</span>.</p>
<p>First, we reflect the data along each coordinate axis. For a 2D spatial field represented by an <span class="math inline">\(n \times n\)</span> matrix, the reflected data takes the form:</p>
<p><span class="math display">\[
\begin{bmatrix}
x_{11} &amp; \cdots &amp; x_{1n_2} &amp; x_{1n_2} &amp; \cdots &amp; x_{11} \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n_11} &amp; \cdots &amp; x_{n_1n_2} &amp; x_{n_1n_2} &amp; \cdots &amp; x_{n_11} \\
x_{n_11} &amp; \cdots &amp; x_{n_1n_2} &amp; x_{n_1n_2} &amp; \cdots &amp; x_{n_11} \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{11} &amp; \cdots &amp; x_{1n_2} &amp; x_{1n_2} &amp; \cdots &amp; x_{11}
\end{bmatrix}
\]</span></p>
<p>This reflection creates a <span class="math inline">\(2n_1 \times 2n_2\)</span> matrix. The matrix is then stacked in lexicographic order before entering into the quadratic forms.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<section id="computational-efficiency" class="level2">
<h2 class="anchored" data-anchor-id="computational-efficiency">Computational Efficiency</h2>
<p>Table 1 presents the results of a benchmark comparing the time it takes to evaluate the gaussian copula density described above. For each grid size, we report the computation time for the exact method and the two approximations, along with the speed-up factor relative to the exact method. Each calculation was performed twenty times and the median times are shown in the table. The Cholesky method is described in the appendix.</p>
<div class="cell-container"><div class="cell-decorator"><pre>In [2]:</pre></div><div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">read_csv</span>(<span class="st">"tables/benchmark_scaled.csv"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gt</span>() <span class="sc">|&gt;</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cols_label</span>(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">Grid =</span> <span class="st">"Grid Size"</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">eig =</span> <span class="st">"Time"</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">sp_1 =</span> <span class="st">"Speed-up"</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">circ =</span> <span class="st">"Time"</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">sp_2 =</span> <span class="st">"Speed-Up"</span>,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">fol =</span> <span class="st">"Time"</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">sp_3 =</span> <span class="st">"Speed-Up"</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tab_spanner</span>(</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">label =</span> <span class="st">"Eigen"</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">columns =</span> <span class="dv">3</span><span class="sc">:</span><span class="dv">4</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tab_spanner</span>(</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">label =</span> <span class="st">"Circulant"</span>,</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">columns =</span> <span class="dv">5</span><span class="sc">:</span><span class="dv">6</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tab_spanner</span>(</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">label =</span> <span class="st">"Folded"</span>,</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">columns =</span> <span class="dv">7</span><span class="sc">:</span><span class="dv">8</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span> </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tab_caption</span>(</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">md</span>(<span class="st">"Benchmarking how long it takes to evaluate the density of a Mátern($</span><span class="sc">\\</span><span class="st">nu$)-like field with correlation parameter $</span><span class="sc">\\</span><span class="st">rho$ scaled to have unit marginal variance"</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Rows: 10 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (8): Grid, Cholesky, eig, sp_1, circ, sp_2, fol, sp_3

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
</div>
<div class="cell-output-display">
<div id="pjfhubafed" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#pjfhubafed table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#pjfhubafed thead, #pjfhubafed tbody, #pjfhubafed tfoot, #pjfhubafed tr, #pjfhubafed td, #pjfhubafed th {
  border-style: none;
}

#pjfhubafed p {
  margin: 0;
  padding: 0;
}

#pjfhubafed .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#pjfhubafed .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#pjfhubafed .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#pjfhubafed .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#pjfhubafed .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#pjfhubafed .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#pjfhubafed .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#pjfhubafed .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#pjfhubafed .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#pjfhubafed .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#pjfhubafed .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#pjfhubafed .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#pjfhubafed .gt_spanner_row {
  border-bottom-style: hidden;
}

#pjfhubafed .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#pjfhubafed .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#pjfhubafed .gt_from_md > :first-child {
  margin-top: 0;
}

#pjfhubafed .gt_from_md > :last-child {
  margin-bottom: 0;
}

#pjfhubafed .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#pjfhubafed .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#pjfhubafed .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#pjfhubafed .gt_row_group_first td {
  border-top-width: 2px;
}

#pjfhubafed .gt_row_group_first th {
  border-top-width: 2px;
}

#pjfhubafed .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#pjfhubafed .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#pjfhubafed .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#pjfhubafed .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#pjfhubafed .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#pjfhubafed .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#pjfhubafed .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#pjfhubafed .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#pjfhubafed .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#pjfhubafed .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#pjfhubafed .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#pjfhubafed .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#pjfhubafed .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#pjfhubafed .gt_left {
  text-align: left;
}

#pjfhubafed .gt_center {
  text-align: center;
}

#pjfhubafed .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#pjfhubafed .gt_font_normal {
  font-weight: normal;
}

#pjfhubafed .gt_font_bold {
  font-weight: bold;
}

#pjfhubafed .gt_font_italic {
  font-style: italic;
}

#pjfhubafed .gt_super {
  font-size: 65%;
}

#pjfhubafed .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#pjfhubafed .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#pjfhubafed .gt_indent_1 {
  text-indent: 5px;
}

#pjfhubafed .gt_indent_2 {
  text-indent: 10px;
}

#pjfhubafed .gt_indent_3 {
  text-indent: 15px;
}

#pjfhubafed .gt_indent_4 {
  text-indent: 20px;
}

#pjfhubafed .gt_indent_5 {
  text-indent: 25px;
}

#pjfhubafed .katex-display {
  display: inline-flex !important;
  margin-bottom: 0.75em !important;
}

#pjfhubafed div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {
  height: 0px !important;
}
</style>

<table class="gt_table caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<caption>Benchmarking how long it takes to evaluate the density of a Mátern(<span class="math inline">\(\nu\)</span>)-like field with correlation parameter <span class="math inline">\(\rho\)</span> scaled to have unit marginal variance</caption>
<thead>
<tr class="header gt_col_headings gt_spanner_row">
<th rowspan="2" id="Grid Size" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Grid Size</th>
<th rowspan="2" id="Cholesky" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Cholesky</th>
<th colspan="2" id="Eigen" class="gt_center gt_columns_top_border gt_column_spanner_outer" data-quarto-table-cell-role="th" scope="colgroup"><span class="gt_column_spanner">Eigen</span></th>
<th colspan="2" id="Circulant" class="gt_center gt_columns_top_border gt_column_spanner_outer" data-quarto-table-cell-role="th" scope="colgroup"><span class="gt_column_spanner">Circulant</span></th>
<th colspan="2" id="Folded" class="gt_center gt_columns_top_border gt_column_spanner_outer" data-quarto-table-cell-role="th" scope="colgroup"><span class="gt_column_spanner">Folded</span></th>
</tr>
<tr class="odd gt_col_headings">
<th id="Time" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Time</th>
<th id="Speed-up" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Speed-up</th>
<th id="Time" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Time</th>
<th id="Speed-Up" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Speed-Up</th>
<th id="Time" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Time</th>
<th id="Speed-Up" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col">Speed-Up</th>
</tr>
</thead>
<tbody class="gt_table_body">
<tr class="odd">
<td class="gt_row gt_left" headers="Grid">10x10</td>
<td class="gt_row gt_left" headers="Cholesky">73.04µs</td>
<td class="gt_row gt_left" headers="eig">173.43µs</td>
<td class="gt_row gt_left" headers="sp_1">0.42x</td>
<td class="gt_row gt_left" headers="circ">31.9µs</td>
<td class="gt_row gt_left" headers="sp_2">2.29x</td>
<td class="gt_row gt_left" headers="fol">44.16µs</td>
<td class="gt_row gt_left" headers="sp_3">1.65x</td>
</tr>
<tr class="even">
<td class="gt_row gt_left" headers="Grid">20x20</td>
<td class="gt_row gt_left" headers="Cholesky">1.43ms</td>
<td class="gt_row gt_left" headers="eig">267.01µs</td>
<td class="gt_row gt_left" headers="sp_1">5.36x</td>
<td class="gt_row gt_left" headers="circ">44µs</td>
<td class="gt_row gt_left" headers="sp_2">32.54x</td>
<td class="gt_row gt_left" headers="fol">151.74µs</td>
<td class="gt_row gt_left" headers="sp_3">9.44x</td>
</tr>
<tr class="odd">
<td class="gt_row gt_left" headers="Grid">30x30</td>
<td class="gt_row gt_left" headers="Cholesky">9.88ms</td>
<td class="gt_row gt_left" headers="eig">808.5µs</td>
<td class="gt_row gt_left" headers="sp_1">12.22x</td>
<td class="gt_row gt_left" headers="circ">110.2µs</td>
<td class="gt_row gt_left" headers="sp_2">89.63x</td>
<td class="gt_row gt_left" headers="fol">243.07µs</td>
<td class="gt_row gt_left" headers="sp_3">40.64x</td>
</tr>
<tr class="even">
<td class="gt_row gt_left" headers="Grid">40x40</td>
<td class="gt_row gt_left" headers="Cholesky">37.88ms</td>
<td class="gt_row gt_left" headers="eig">2.06ms</td>
<td class="gt_row gt_left" headers="sp_1">18.35x</td>
<td class="gt_row gt_left" headers="circ">141.5µs</td>
<td class="gt_row gt_left" headers="sp_2">267.64x</td>
<td class="gt_row gt_left" headers="fol">393.79µs</td>
<td class="gt_row gt_left" headers="sp_3">96.18x</td>
</tr>
<tr class="odd">
<td class="gt_row gt_left" headers="Grid">50x50</td>
<td class="gt_row gt_left" headers="Cholesky">106.28ms</td>
<td class="gt_row gt_left" headers="eig">4.56ms</td>
<td class="gt_row gt_left" headers="sp_1">23.33x</td>
<td class="gt_row gt_left" headers="circ">188.5µs</td>
<td class="gt_row gt_left" headers="sp_2">563.82x</td>
<td class="gt_row gt_left" headers="fol">604.87µs</td>
<td class="gt_row gt_left" headers="sp_3">175.7x</td>
</tr>
<tr class="even">
<td class="gt_row gt_left" headers="Grid">60x60</td>
<td class="gt_row gt_left" headers="Cholesky">253.66ms</td>
<td class="gt_row gt_left" headers="eig">8.79ms</td>
<td class="gt_row gt_left" headers="sp_1">28.86x</td>
<td class="gt_row gt_left" headers="circ">242.4µs</td>
<td class="gt_row gt_left" headers="sp_2">1046.59x</td>
<td class="gt_row gt_left" headers="fol">836.07µs</td>
<td class="gt_row gt_left" headers="sp_3">303.4x</td>
</tr>
<tr class="odd">
<td class="gt_row gt_left" headers="Grid">70x70</td>
<td class="gt_row gt_left" headers="Cholesky">538.42ms</td>
<td class="gt_row gt_left" headers="eig">16.81ms</td>
<td class="gt_row gt_left" headers="sp_1">32.04x</td>
<td class="gt_row gt_left" headers="circ">333.1µs</td>
<td class="gt_row gt_left" headers="sp_2">1616.37x</td>
<td class="gt_row gt_left" headers="fol">1.17ms</td>
<td class="gt_row gt_left" headers="sp_3">459.89x</td>
</tr>
<tr class="even">
<td class="gt_row gt_left" headers="Grid">80x80</td>
<td class="gt_row gt_left" headers="Cholesky">1.02s</td>
<td class="gt_row gt_left" headers="eig">29.59ms</td>
<td class="gt_row gt_left" headers="sp_1">34.63x</td>
<td class="gt_row gt_left" headers="circ">393.9µs</td>
<td class="gt_row gt_left" headers="sp_2">2601.89x</td>
<td class="gt_row gt_left" headers="fol">1.59ms</td>
<td class="gt_row gt_left" headers="sp_3">643.46x</td>
</tr>
<tr class="odd">
<td class="gt_row gt_left" headers="Grid">90x90</td>
<td class="gt_row gt_left" headers="Cholesky">1.81s</td>
<td class="gt_row gt_left" headers="eig">48.56ms</td>
<td class="gt_row gt_left" headers="sp_1">37.27x</td>
<td class="gt_row gt_left" headers="circ">598.9µs</td>
<td class="gt_row gt_left" headers="sp_2">3022.23x</td>
<td class="gt_row gt_left" headers="fol">2.04ms</td>
<td class="gt_row gt_left" headers="sp_3">888.28x</td>
</tr>
<tr class="even">
<td class="gt_row gt_left" headers="Grid">100x100</td>
<td class="gt_row gt_left" headers="Cholesky">3.09s</td>
<td class="gt_row gt_left" headers="eig">76.03ms</td>
<td class="gt_row gt_left" headers="sp_1">40.59x</td>
<td class="gt_row gt_left" headers="circ">593µs</td>
<td class="gt_row gt_left" headers="sp_2">5204.38x</td>
<td class="gt_row gt_left" headers="fol">2.42ms</td>
<td class="gt_row gt_left" headers="sp_3">1276.46x</td>
</tr>
</tbody>
</table>

</div>
</div>
</div></div>
</section>
</section>
<section id="appendix" class="level1 appendix">
<h1 class="appendix">Appendix</h1>
<section id="cholesky-methods" class="level2">
<h2 class="anchored" data-anchor-id="cholesky-methods">Cholesky Methods</h2>
<p>Standard methods of evaluating multivariate normal densities using the Cholesky decomposition were implemented to compare with the new methods for benchmarking.</p>
<section id="unscaled-precision-matrix" class="level3">
<h3 class="anchored" data-anchor-id="unscaled-precision-matrix">Unscaled Precision Matrix</h3>
<section id="precision-matrix-construction" class="level4">
<h4 class="anchored" data-anchor-id="precision-matrix-construction">Precision Matrix Construction</h4>
<p>We start by constructing the precision matrix <span class="math inline">\(Q\)</span> for a 2D Matérn field on a grid of size <span class="math inline">\(d_x \times d_y\)</span>:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, <span class="math inline">\(Q_1\)</span> and <span class="math inline">\(Q_2\)</span> are 1D precision matrices for the x and y dimensions respectively (typically AR(1)-like structures), and <span class="math inline">\(I_{d_x}\)</span> and <span class="math inline">\(I_{d_y}\)</span> are identity matrices of appropriate sizes.</p>
</section>
<section id="density-computation" class="level4">
<h4 class="anchored" data-anchor-id="density-computation">Density Computation</h4>
<p>For a Matérn field with smoothness parameter <span class="math inline">\(\nu\)</span>, we need to work with <span class="math inline">\(Q^{\nu+1}\)</span>. We can efficiently compute the log-determinant, <span class="math inline">\(\log|Q^{\nu+1}|\)</span>, and the quadratic form, <span class="math inline">\(x^T Q^{\nu+1} x\)</span>, without explicitly forming <span class="math inline">\(Q^{\nu+1}\)</span>. To do this, we compute the Cholesky decomposition, <span class="math inline">\(Q = LL^T\)</span>, where L is a lower triangular matrix, and make use of the following equations:</p>
<p><span class="math display">\[
\log|Q^{\nu+1}| = (\nu+1)\log|Q| = 2(\nu+1)\sum_{i}\log(L_{ii}),
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
x^T Q x &amp;= x^T L L^T x = ||L^T x||_2^2 \\
x^T Q^2 x &amp;=  x^T L L^T L L^T x = ||LL^T x||_2^2 \\
x^T Q^3 x &amp;=  x^T L L^T L L^T L L^T x = ||L^TLL^T x||_2^2.
\end{aligned}
\]</span></p>
</section>
<section id="algorithm" class="level4">
<h4 class="anchored" data-anchor-id="algorithm">Algorithm</h4>
<ol type="1">
<li>Construct <span class="math inline">\(Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2\)</span></li>
<li>Compute Cholesky decomposition <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute log-determinant: <span class="math inline">\(\log|Q^{\nu+1}| = 2(\nu+1)\sum_{i}\log(L_{ii})\)</span></li>
<li>For each observation <span class="math inline">\(x\)</span>:
<ol type="i">
<li>Initialize <span class="math inline">\(y = x\)</span></li>
<li>For <span class="math inline">\(j\)</span> from 0 to <span class="math inline">\(\nu\)</span>:
<ul>
<li>If <span class="math inline">\(j\)</span> is even: <span class="math inline">\(y = L^T y\)</span></li>
<li>If <span class="math inline">\(j\)</span> is odd: <span class="math inline">\(y = L y\)</span></li>
</ul></li>
<li>Compute quadratic form <span class="math inline">\(q = y^Ty\)</span></li>
</ol></li>
<li>Compute log-density: <span class="math inline">\(\log p(x) = -\frac{1}{2}(d\log(2\pi) + \log|Q^{\nu+1}| + q)\)</span></li>
</ol>
</section>
</section>
<section id="scaled-precision-matrix" class="level3">
<h3 class="anchored" data-anchor-id="scaled-precision-matrix">Scaled Precision Matrix</h3>
<section id="precision-matrix-construction-1" class="level4">
<h4 class="anchored" data-anchor-id="precision-matrix-construction-1">Precision Matrix Construction</h4>
<p>We start by constructing the precision matrix <span class="math inline">\(Q\)</span> for a 2D Matérn field on a grid of size <span class="math inline">\(d_x \times d_y\)</span>:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, <span class="math inline">\(Q_1\)</span> and <span class="math inline">\(Q_2\)</span> are 1D precision matrices for the x and y dimensions respectively (typically AR(1)-like structures), and <span class="math inline">\(I_{d_x}\)</span> and <span class="math inline">\(I_{d_y}\)</span> are identity matrices of appropriate sizes. We will then have to work with the matrix <span class="math inline">\(Q^{\nu + 1}\)</span>.</p>
<p>To ensure unit marginal variances, we need to scale this precision matrix. Let <span class="math inline">\(D\)</span> be a diagonal matrix where <span class="math inline">\(D_{ii} = \sqrt{\Sigma_{ii}}\)</span>, and <span class="math inline">\(\Sigma = (Q^{\nu+1})^{-1}\)</span>. The scaled precision matrix is then: <span class="math display">\[
\tilde{Q} = DQ^{\nu+1}D
\]</span></p>
</section>
<section id="efficient-computation-of-scaling-matrix-d" class="level4">
<h4 class="anchored" data-anchor-id="efficient-computation-of-scaling-matrix-d">Efficient Computation of Scaling Matrix D</h4>
<ol type="1">
<li>Compute the Cholesky decomposition of the original <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute <span class="math inline">\(R = L^{-1}\)</span>, so that <span class="math inline">\(S = Q^{-1} = R^TR\)</span>.</li>
<li>We then calculate the entries in <span class="math inline">\(D\)</span> using the following steps:
<ol type="i">
<li>For <span class="math inline">\(\nu = 0\)</span>, <span class="math inline">\(D_{ii} = \sqrt{\Sigma_{ii}} = \sqrt{\sum_j (R_{ji})^2}\)</span>, the column-wise norm of <span class="math inline">\(R\)</span>.</li>
<li>For <span class="math inline">\(\nu = 1\)</span>, we use the column-wise norm of <span class="math inline">\(R^TR\)</span></li>
<li>For <span class="math inline">\(\nu = 2\)</span>, we use the column-wise norm of <span class="math inline">\(RR^TR\)</span></li>
</ol></li>
</ol>
</section>
<section id="log-determinant" class="level4">
<h4 class="anchored" data-anchor-id="log-determinant">Log determinant</h4>
<ol type="1">
<li>First, note that <span class="math inline">\(\log|\tilde{Q}| = \log|DQ^{\nu+1}D| = 2\log|D| + \log|Q^{\nu+1}|\)</span></li>
<li>We can compute <span class="math inline">\(\log|D|\)</span> directly from the diagonal elements of D, i.e.&nbsp;<span class="math inline">\(\log|D| = \sum_i \log(D_{ii})\)</span></li>
<li>For <span class="math inline">\(\log|Q^{\nu+1}|\)</span>, we can use the properties of the Cholesky decomposition: <span class="math inline">\(\log|Q^{\nu+1}| = (\nu+1)\log|Q| = (\nu+1)\log|LL^T| = 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
<li>Combining these, we get <span class="math inline">\(\log|\tilde{Q}| = 2\sum_i \log(D_{ii}) + 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
</ol>
</section>
<section id="quadratic-form" class="level4">
<h4 class="anchored" data-anchor-id="quadratic-form">Quadratic Form</h4>
<ol type="1">
<li>First, note that <span class="math inline">\(z^T\tilde{Q}z = z^TDQ^{\nu+1}Dz = (Dz)^TQ^{\nu+1}(Dz)\)</span></li>
<li>Let <span class="math inline">\(y = Dz\)</span>. We can compute this element-wise as <span class="math inline">\(y_i = D_{ii}z_i\)</span></li>
<li>Now we compute <span class="math inline">\(y^TQ^{\nu+1}y\)</span> as in the unscaled case.</li>
</ol>
</section>
<section id="algorithm-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-1">Algorithm</h4>
<p>Putting it all together, here’s the algorithm for computing the log-density of the Gaussian copula using the scaled precision matrix:</p>
<ol type="1">
<li>Construct <span class="math inline">\(Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2\)</span></li>
<li>Compute Cholesky decomposition <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute <span class="math inline">\(R = L^{-1}\)</span> and use it to compute D as described earlier</li>
<li>Compute log-determinant: <span class="math inline">\(\log|\tilde{Q}| = 2\sum_i \log(D_{ii}) + 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
<li>For each observation <span class="math inline">\(z = \Phi^{-1}(u)\)</span>:
<ol type="i">
<li>Compute <span class="math inline">\(y = Dz\)</span></li>
<li>Compute <span class="math inline">\(y^TQ^{\nu+1}y\)</span> as in the unscaled case.</li>
</ol></li>
<li>Compute log-density: <span class="math inline">\(\log c(u) = -\frac{1}{2}(d\log(2\pi) + \log|\tilde{Q}| + q - z^Tz)\)</span></li>
</ol>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-besag2005" class="csl-entry" role="listitem">
Besag, Julian, and Debashis Mondal. 2005. <span>“First-Order Intrinsic Autoregressions and the de Wijs Process.”</span> <em>Biometrika</em> 92 (4): 909–20. <a href="https://doi.org/10.1093/biomet/92.4.909">https://doi.org/10.1093/biomet/92.4.909</a>.
</div>
<div id="ref-gray2006" class="csl-entry" role="listitem">
Gray, Robert M. 2006. <span>“Toeplitz and Circulant Matrices: A Review.”</span> <em>Foundations and Trends® in Communications and Information Theory</em> 2 (3): 155–239. <a href="https://doi.org/10.1561/0100000006">https://doi.org/10.1561/0100000006</a>.
</div>
<div id="ref-joe1997" class="csl-entry" role="listitem">
Joe, Harry. 1997. <em>Multivariate Models and Multivariate Dependence Concepts</em>. New York: Chapman; Hall/CRC.
</div>
<div id="ref-kent2022" class="csl-entry" role="listitem">
Kent, John T., and Kanti V. Mardia. 2022. <em>Spatial Analysis</em>. John Wiley &amp; Sons.
</div>
<div id="ref-knorr-heldBayesianModellingInseparable2000" class="csl-entry" role="listitem">
Knorr-Held, Leonhard. 2000. <span>“Bayesian Modelling of Inseparable Space-Time Variation in Disease Risk.”</span> <em>Statistics in Medicine</em> 19 (17-18): 2555–67. <a href="https://doi.org/10.1002/1097-0258(20000915/30)19:17/18<2555::AID-SIM587>3.0.CO;2-#">https://doi.org/10.1002/1097-0258(20000915/30)19:17/18&lt;2555::AID-SIM587&gt;3.0.CO;2-#</a>.
</div>
<div id="ref-lindgren2011" class="csl-entry" role="listitem">
Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. <span>“An Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 73 (4): 423–98. <a href="https://doi.org/10.1111/j.1467-9868.2011.00777.x">https://doi.org/10.1111/j.1467-9868.2011.00777.x</a>.
</div>
<div id="ref-matrixa" class="csl-entry" role="listitem">
<span>“Matrix Analysis for Scientists and Engineers | SIAM Publications Library.”</span> n.d. <a href="https://epubs.siam.org/doi/book/10.1137/1.9780898717907">https://epubs.siam.org/doi/book/10.1137/1.9780898717907</a>.
</div>
<div id="ref-mondal2018" class="csl-entry" role="listitem">
Mondal, D. 2018. <span>“On Edge Correction of Conditional and Intrinsic Autoregressions.”</span> <em>Biometrika</em> 105 (2): 447–54. <a href="https://doi.org/10.1093/biomet/asy014">https://doi.org/10.1093/biomet/asy014</a>.
</div>
<div id="ref-nelsen2006" class="csl-entry" role="listitem">
Nelsen, Roger B. 2006. <em>An Introduction to Copulas</em>. 2nd ed. Springer Series in Statistics. New York: Springer.
</div>
<div id="ref-rue2005" class="csl-entry" role="listitem">
Rue, Havard, and Leonhard Held. 2005. <em>Gaussian Markov Random Fields: Theory and Applications</em>. CRC Press.
</div>
<div id="ref-rue2009" class="csl-entry" role="listitem">
Rue, Håvard, Sara Martino, and Nicolas Chopin. 2009. <span>“Approximate Bayesian Inference for Latent Gaussian Models by Using Integrated Nested Laplace Approximations.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 71 (2): 319–92. <a href="https://doi.org/10.1111/j.1467-9868.2008.00700.x">https://doi.org/10.1111/j.1467-9868.2008.00700.x</a>.
</div>
<div id="ref-sklar1959" class="csl-entry" role="listitem">
Sklar, M. 1959. <span>“Fonctions de Répartition à n Dimensions Et Leurs Marges.”</span> <em>Annales de l’ISUP</em> VIII (3): 229–31. <a href="https://hal.science/hal-04094463">https://hal.science/hal-04094463</a>.
</div>
</div>
</section>
</section>
</section>
</section>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>  </div> <!-- /content --> 
  
</body></html>