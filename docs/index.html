<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="dcterms.date" content="2024-08-15">

<title>Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations">
<meta name="citation_abstract" content="This paper presents an algorithm for efficient computation of Gaussian copula densities using Gaussian Markov Random Field (GMRF) precision structures. We introduce a Matérn-like precision matrix with unit marginal variance, leveraging a Kronecker sum structure that allows for fast eigendecomposition. The method avoids explicit formation and inversion of large precision matrices, making it particularly suitable for high-dimensional spatial data. We propose two approximation methods: circulant and folded circulant, which utilize the computational efficiency of Fast Fourier Transforms (FFTs). The circulant approximation treats the spatial field as if it were on a torus, where opposite edges are connected. The folded circulant approximation, however, uses a reflection boundary condition, effectively doubling the size of the field by reflecting the data along each coordinate axis. This approach potentially offers improved accuracy near field edges, addressing a common limitation of periodic boundary conditions.">
<meta name="citation_author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="citation_publication_date" content="2024-08-15">
<meta name="citation_cover_date" content="2024-08-15">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-08-15">
<meta name="citation_language" content="en">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Efficient Gaussian Copula Density Computation for Large-Scale Spatial Data: A Matérn-like GMRF Approach with Circulant and Folded Circulant Approximations</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Author</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author"><a href="bggj.is">Brynjólfur Gauti Guðrúnar Jónsson</a> <a href="mailto:brynjolfur@hi.is" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        University of Iceland
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">August 15, 2024</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></p></div><div class="quarto-title-meta-contents"><p><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF (acs)</a></p></div><div class="quarto-title-meta-contents"><p><a href="index-meca.zip" data-meca-link="true"><i class="bi bi-archive"></i>MECA Bundle</a></p></div></div></div>
    </div>

    <div>
      <div class="abstract">
        <div class="block-title">Abstract</div>
        This paper presents an algorithm for efficient computation of Gaussian copula densities using Gaussian Markov Random Field (GMRF) precision structures. We introduce a Matérn-like precision matrix with unit marginal variance, leveraging a Kronecker sum structure that allows for fast eigendecomposition. The method avoids explicit formation and inversion of large precision matrices, making it particularly suitable for high-dimensional spatial data. We propose two approximation methods: circulant and folded circulant, which utilize the computational efficiency of Fast Fourier Transforms (FFTs). The circulant approximation treats the spatial field as if it were on a torus, where opposite edges are connected. The folded circulant approximation, however, uses a reflection boundary condition, effectively doubling the size of the field by reflecting the data along each coordinate axis. This approach potentially offers improved accuracy near field edges, addressing a common limitation of periodic boundary conditions.
      </div>
    </div>


    <div class="quarto-other-links-text-target">
    <div class="quarto-code-links"><div class="quarto-title-meta-heading">Code Links</div><div class="quarto-title-meta-contents"><span style="padding-right: 0.5em;"><a href="https://github.com/bgautijonsson/copulas"><i class="bi bi-github"></i>GitHub Repo</a>,</span><span style="padding-right: 0.5em;"><a href="https://github.com/bgautijonsson/copulas"><i class="bi bi-code"></i>Stan Code</a>,</span><span><a href="https://github.com/bgautijonsson/stdmatern"><i class="bi bi-code"></i>R Package</a></span></div></div></div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#problem-formulation" id="toc-problem-formulation" class="nav-link" data-scroll-target="#problem-formulation">Problem Formulation</a></li>
  <li><a href="#review" id="toc-review" class="nav-link" data-scroll-target="#review">Review</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#gaussian-copula-density-computation" id="toc-gaussian-copula-density-computation" class="nav-link" data-scroll-target="#gaussian-copula-density-computation">Gaussian Copula Density Computation</a></li>
  <li><a href="#precision-matrix-structure" id="toc-precision-matrix-structure" class="nav-link" data-scroll-target="#precision-matrix-structure">Precision Matrix Structure</a></li>
  <li><a href="#computation-process" id="toc-computation-process" class="nav-link" data-scroll-target="#computation-process">Computation Process</a>
  <ul class="collapse">
  <li><a href="#step-1-eigendecomposition-of-mathbfq_1" id="toc-step-1-eigendecomposition-of-mathbfq_1" class="nav-link" data-scroll-target="#step-1-eigendecomposition-of-mathbfq_1">Step 1: Eigendecomposition of <span class="math inline">\(\mathbf{Q}_1\)</span></a></li>
  <li><a href="#step-2-computation-of-marginal-standard-deviations" id="toc-step-2-computation-of-marginal-standard-deviations" class="nav-link" data-scroll-target="#step-2-computation-of-marginal-standard-deviations">Step 2: Computation of Marginal Standard Deviations</a></li>
  <li><a href="#step-3-scaling-the-eigendecomposition" id="toc-step-3-scaling-the-eigendecomposition" class="nav-link" data-scroll-target="#step-3-scaling-the-eigendecomposition">Step 3: Scaling the Eigendecomposition</a></li>
  <li><a href="#step-4-efficient-computation-of-log-density" id="toc-step-4-efficient-computation-of-log-density" class="nav-link" data-scroll-target="#step-4-efficient-computation-of-log-density">Step 4: Efficient Computation of Log-Density</a></li>
  </ul></li>
  <li><a href="#circulant-and-folded-circulant-approximations" id="toc-circulant-and-folded-circulant-approximations" class="nav-link" data-scroll-target="#circulant-and-folded-circulant-approximations">Circulant and Folded Circulant Approximations</a>
  <ul class="collapse">
  <li><a href="#circulant-matrices" id="toc-circulant-matrices" class="nav-link" data-scroll-target="#circulant-matrices">Circulant Matrices</a></li>
  <li><a href="#block-circulant-matrices" id="toc-block-circulant-matrices" class="nav-link" data-scroll-target="#block-circulant-matrices">Block Circulant Matrices</a></li>
  <li><a href="#computational-advantages" id="toc-computational-advantages" class="nav-link" data-scroll-target="#computational-advantages">Computational Advantages</a></li>
  <li><a href="#approximations-for-q1" id="toc-approximations-for-q1" class="nav-link" data-scroll-target="#approximations-for-q1">Approximations for Q1</a></li>
  <li><a href="#extension-to-the-full-q-matrix" id="toc-extension-to-the-full-q-matrix" class="nav-link" data-scroll-target="#extension-to-the-full-q-matrix">Extension to the Full Q Matrix</a></li>
  </ul></li>
  <li><a href="#computation-with-circulant-approximation" id="toc-computation-with-circulant-approximation" class="nav-link" data-scroll-target="#computation-with-circulant-approximation">Computation with Circulant Approximation</a>
  <ul class="collapse">
  <li><a href="#construct-the-base-matrix" id="toc-construct-the-base-matrix" class="nav-link" data-scroll-target="#construct-the-base-matrix">1. Construct the Base Matrix</a></li>
  <li><a href="#compute-initial-eigenvalues" id="toc-compute-initial-eigenvalues" class="nav-link" data-scroll-target="#compute-initial-eigenvalues">2. Compute Initial Eigenvalues</a></li>
  <li><a href="#compute-marginal-variance-and-rescale-eigenvalues" id="toc-compute-marginal-variance-and-rescale-eigenvalues" class="nav-link" data-scroll-target="#compute-marginal-variance-and-rescale-eigenvalues">3. Compute Marginal Variance and Rescale Eigenvalues</a></li>
  <li><a href="#compute-log-determinant" id="toc-compute-log-determinant" class="nav-link" data-scroll-target="#compute-log-determinant">4. Compute Log-Determinant</a></li>
  <li><a href="#compute-quadratic-form" id="toc-compute-quadratic-form" class="nav-link" data-scroll-target="#compute-quadratic-form">5. Compute Quadratic Form</a></li>
  <li><a href="#compute-the-log-density" id="toc-compute-the-log-density" class="nav-link" data-scroll-target="#compute-the-log-density">6. Compute the Log-Density</a></li>
  </ul></li>
  <li><a href="#computation-with-folded-circulant-approximation" id="toc-computation-with-folded-circulant-approximation" class="nav-link" data-scroll-target="#computation-with-folded-circulant-approximation">Computation with Folded Circulant Approximation</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#computational-efficiency" id="toc-computational-efficiency" class="nav-link" data-scroll-target="#computational-efficiency">Computational Efficiency</a></li>
  </ul></li>
  
  </ul>
<div class="quarto-alternate-notebooks"><h2>Notebooks</h2><ul><li><a href="Readme-preview.html"><i class="bi bi-journal-code"></i>Readme.MD</a></li></ul></div></nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="introduction" class="level1">
<h1>Introduction</h1>
<section id="problem-formulation" class="level2">
<h2 class="anchored" data-anchor-id="problem-formulation">Problem Formulation</h2>
<p>Consider a spatial field on a regular <span class="math inline">\(n \times n\)</span> grid. Our objective is to compute the Gaussian copula density efficiently for this field. This computation involves:</p>
<ol type="1">
<li>Specifying a precision matrix <span class="math inline">\(\mathbf{Q}\)</span> that represents the spatial dependence structure.</li>
<li>Ensuring the implied covariance matrix <span class="math inline">\(\mathbf{\Sigma} = \mathbf{Q}^{-1}\)</span> has unit diagonal elements.</li>
<li>Computing the density for large spatial fields in a computationally efficient manner.</li>
</ol>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>Gaussian Markov Random Fields (GMRFs) and copulas are two powerful statistical tools, each offering unique strengths in modeling complex data structures. GMRFs excel in capturing spatial and temporal dependencies, particularly in fields such as environmental science, epidemiology, and image analysis. Their ability to represent local dependencies through sparse precision matrices makes them computationally attractive for high-dimensional problems. Copulas, on the other hand, provide a flexible framework for modeling multivariate dependencies, allowing separate specification of marginal distributions and their joint behavior.</p>
<p>The Gaussian copula, in particular, has gained popularity due to its interpretability and connection to the multivariate normal distribution. However, combining GMRFs with copulas has historically been computationally challenging, limiting their joint application to smaller datasets or simpler models.</p>
<p>Let <span class="math inline">\(\mathbf{X} = (X_1, X_2, \ldots, X_n)\)</span> be a multivariate random vector with marginal distribution functions <span class="math inline">\(F_i\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>. The joint distribution function of <span class="math inline">\(\mathbf{X}\)</span> can be written as:</p>
<p><span class="math display">\[
F_{\mathbf{X}}(\mathbf{x}) = C(F_1(x_1), F_2(x_2), \ldots, F_n(x_n)),
\]</span></p>
<p>where <span class="math inline">\(C\)</span> is the Gaussian copula defined by the GMRF precision matrix <span class="math inline">\(\mathbf{Q}\)</span>. The Gaussian copula <span class="math inline">\(C\)</span> is given by:</p>
<p><span class="math display">\[
C(u_1, u_2, \ldots, u_n) = \Phi_\mathbf{Q}(\Phi^{-1}(u_1), \Phi^{-1}(u_2), \ldots, \Phi^{-1}(u_n)),
\]</span></p>
<p>where <span class="math inline">\(\Phi_\mathbf{Q}\)</span> is the joint cumulative distribution function of a multivariate normal distribution with mean vector <span class="math inline">\(\mathbf{0}\)</span> and precision matrix <span class="math inline">\(\mathbf{Q}\)</span>, and <span class="math inline">\(\Phi^{-1}\)</span> is the inverse of the standard normal cumulative distribution function.</p>
<p>A critical requirement for the precision matrix <span class="math inline">\(\mathbf{Q}\)</span> governing the GMRF copula <span class="math inline">\(C\)</span> is that <span class="math inline">\(\mathbf{\Sigma} = \mathbf{Q}^{-1}\)</span> should have a unit diagonal, i.e.&nbsp;the marginal variance is equal to one everywhere.. This ensures it operates on the same scale as the transformed data, <span class="math inline">\(\Phi^{-1}(u_i)\)</span>. However, this can be challenging as GMRFs are typically defined in terms of precision matrices that often imply non-unit marginal variances.</p>
<p>This paper presents a novel algorithm that bridges the gap between GMRFs and copulas, allowing for fast and efficient computation of Gaussian copula densities using GMRF precision structures. Our method focuses on creating a Matérn-like precision matrix <span class="math inline">\(\mathbf{Q}\)</span> with unit marginal variance and efficiently computing the multivariate Gaussian copula density of <span class="math inline">\(\mathbf{Z} = \Phi^{-1}(\mathbf{u})\)</span>, where <span class="math inline">\(u_i \sim \text{Uniform}(0, 1)\)</span>, <span class="math inline">\(i = 1, \dots, n\)</span>.</p>
<p>The key innovation lies in leveraging the special structure of the precision matrix:</p>
<p><span class="math display">\[
\mathbf{Q} = \mathbf{Q}_1 \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{Q}_1,
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Q}_1\)</span> is the precision matrix of a standardized one-dimensional AR(1) process and <span class="math inline">\(\otimes\)</span> denotes the Kronecker product. By employing efficient eigendecomposition techniques, our method avoids explicit formation and inversion of the large precision matrix <span class="math inline">\(\mathbf{Q}\)</span>, making it particularly suitable for high-dimensional spatial data. In additions to the exact method, we mention approximations to <span class="math inline">\(\mathbf{Q}\)</span> using circuland and folded circulant matrices.</p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="gaussian-copula-density-computation" class="level2">
<h2 class="anchored" data-anchor-id="gaussian-copula-density-computation">Gaussian Copula Density Computation</h2>
<p>The Gaussian copula density for a random vector <span class="math inline">\(\mathbf{U} = (U_1, ..., U_n)\)</span> with <span class="math inline">\(U_i \sim \text{Uniform}(0,1)\)</span> is given by:</p>
<p><span class="math display">\[
c(\mathbf{u}) = |\mathbf{Q}|^{1/2} \exp\left(-\frac{1}{2}\mathbf{z}^T(\mathbf{Q} - \mathbf{I})\mathbf{z}\right)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{z} = (z_1, ..., z_n)\)</span> with <span class="math inline">\(z_i = \Phi^{-1}(u_i)\)</span>, <span class="math inline">\(\mathbf{Q}\)</span> is the precision matrix, and <span class="math inline">\(\mathbf{I}\)</span> is the identity matrix.</p>
<p>The log-density can be expressed as:</p>
<p><span class="math display">\[
\log c(\mathbf{u}) = \frac{1}{2}\log|\mathbf{Q}| - \frac{1}{2}\mathbf{z}^T\mathbf{Q}\mathbf{z} + \frac{1}{2}\mathbf{z}^T\mathbf{z}
\]</span></p>
<p>Our goal is to efficiently compute this log-density for large spatial fields.</p>
</section>
<section id="precision-matrix-structure" class="level2">
<h2 class="anchored" data-anchor-id="precision-matrix-structure">Precision Matrix Structure</h2>
<p>We define the precision matrix <span class="math inline">\(\mathbf{Q}\)</span> as:</p>
<p><span class="math display">\[
\mathbf{Q} = (\mathbf{Q}_1 \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{Q}_1)^{(\nu + 1)}, \quad \nu \in \{0, 1, 2\}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Q}_1\)</span> is the precision matrix of a one-dimensional AR(1) process:</p>
<p><span class="math display">\[
\mathbf{Q}_1 = \frac{1}{1-\rho^2}
\begin{bmatrix}
1 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}
\]</span></p>
<p>The matrix, <span class="math inline">\(\mathbf Q\)</span>, is then scaled so that its inverse, <span class="math inline">\(\mathbf \Sigma = \mathbf Q^{-1}\)</span> has unit diagonals, i.e.&nbsp;<span class="math inline">\(\mathbf \Sigma_{ii} = 1\)</span>.</p>
</section>
<section id="computation-process" class="level2">
<h2 class="anchored" data-anchor-id="computation-process">Computation Process</h2>
<section id="step-1-eigendecomposition-of-mathbfq_1" class="level3">
<h3 class="anchored" data-anchor-id="step-1-eigendecomposition-of-mathbfq_1">Step 1: Eigendecomposition of <span class="math inline">\(\mathbf{Q}_1\)</span></h3>
<p>We first compute the eigendecomposition of <span class="math inline">\(\mathbf{Q}_1\)</span>:</p>
<p><span class="math display">\[
\mathbf{Q}_1 = \mathbf{V}\mathbf{\Lambda}\mathbf{V}^T
\]</span></p>
<p>where <span class="math inline">\(\mathbf{V}\)</span> is the matrix of eigenvectors and <span class="math inline">\(\mathbf{\Lambda}\)</span> is the diagonal matrix of eigenvalues. Then, the eigendecomposition of <span class="math inline">\(\mathbf{Q}\)</span> is:</p>
<p><span class="math display">\[
\mathbf{Q} = (\mathbf{V} \otimes \mathbf{V})(\mathbf{\Lambda} \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{\Lambda})^{(\nu + 1)}(\mathbf{V} \otimes \mathbf{V})^T.
\]</span></p>
<p>This means that the eigenvectors of <span class="math inline">\(\mathbf{Q}\)</span> are <span class="math inline">\(\mathbf{v}_j \otimes \mathbf{v}_i\)</span> and the corresponding eigenvalues are <span class="math inline">\(\lambda_i + \lambda_j\)</span>.</p>
</section>
<section id="step-2-computation-of-marginal-standard-deviations" class="level3">
<h3 class="anchored" data-anchor-id="step-2-computation-of-marginal-standard-deviations">Step 2: Computation of Marginal Standard Deviations</h3>
<p>Using the eigendecomposition of <span class="math inline">\(\mathbf{Q}_1\)</span>, we compute the marginal standard deviations and store them in a vector <span class="math inline">\(\mathbf{\sigma}\)</span>, i.e.&nbsp;<span class="math inline">\(\sigma_i = \sqrt{\Sigma_{ii}}\)</span>:</p>
<p><span class="math display">\[
\mathbf{\sigma} = \sqrt{\sum_{i,j} \frac{(\mathbf{v}_j \otimes \mathbf{v}_i)^2}{(\lambda_i + \lambda_j)^\nu}}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{v}_i\)</span> are the eigenvectors and <span class="math inline">\(\lambda_i\)</span> are the eigenvalues of <span class="math inline">\(\mathbf{Q}_1\)</span>. Thus, <span class="math inline">\(\sigma\)</span> will be a vector of length <span class="math inline">\(n^2\)</span>.</p>
</section>
<section id="step-3-scaling-the-eigendecomposition" class="level3">
<h3 class="anchored" data-anchor-id="step-3-scaling-the-eigendecomposition">Step 3: Scaling the Eigendecomposition</h3>
<p>We scale the eigendecomposition of <span class="math inline">\(\mathbf{Q}\)</span> using the marginal standard deviations:</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{\widetilde  Q} &amp;= \mathbf{D}\mathbf{Q}\mathbf{D} \\
&amp;= \mathbf{D}(\mathbf{V} \otimes \mathbf{V})(\mathbf{\Lambda} \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{\Lambda})^\nu(\mathbf{V} \otimes \mathbf{V})^T\mathbf{D} \\
&amp;= (\mathbf{\widetilde V} \otimes \mathbf{\widetilde V})(\mathbf{\widetilde\Lambda} \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{\widetilde \Lambda})(\mathbf{\widetilde V} \otimes \mathbf{\widetilde V})^T
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{D}\)</span> is a diagonal matrix with <span class="math inline">\(D_{ii} = \sigma_i\)</span>.</p>
</section>
<section id="step-4-efficient-computation-of-log-density" class="level3">
<h3 class="anchored" data-anchor-id="step-4-efficient-computation-of-log-density">Step 4: Efficient Computation of Log-Density</h3>
<p>Using this scaled eigendecomposition, we efficiently compute:</p>
<ol type="1">
<li><p>Log-determinant: <span class="math inline">\(\log|\mathbf{\widetilde Q}| = \sum_{i,j} \log(\widetilde\lambda_i + \widetilde\lambda_j)\)</span></p></li>
<li><p>Quadratic form: <span class="math inline">\(\mathbf{z}^T\mathbf{\widetilde Q}\mathbf{z} = \sum_{i,j} (\widetilde\lambda_i + \widetilde\lambda_j) y_{ij}^2\)</span>, where <span class="math inline">\(y_{ij} = (\mathbf{\widetilde v}_j \otimes \mathbf{\widetilde v}_i)^T\mathbf{z}\)</span></p></li>
</ol>
<p>This approach allows for efficient computation of the Gaussian copula density without explicitly forming the full <span class="math inline">\(n^2 \times n^2\)</span> precision matrix <span class="math inline">\(\mathbf{Q}\)</span> or its inverse <span class="math inline">\(\mathbf{\Sigma}\)</span>.</p>
</section>
</section>
<section id="circulant-and-folded-circulant-approximations" class="level2">
<h2 class="anchored" data-anchor-id="circulant-and-folded-circulant-approximations">Circulant and Folded Circulant Approximations</h2>
<p>While the eigendecomposition method provides an exact solution, it can be computationally expensive for very large spatial fields. To address this, we introduce circulant and folded circulant approximations that offer potential computational advantages.</p>
<section id="circulant-matrices" class="level3">
<h3 class="anchored" data-anchor-id="circulant-matrices">Circulant Matrices</h3>
<p>A circulant matrix <span class="math inline">\(C\)</span> is a special kind of matrix where each row is a cyclic shift of the row above it. It can be fully specified by its first row or column, called the base <span class="math inline">\(c\)</span>:</p>
<p><span class="math display">\[
C = \begin{pmatrix}
c_0 &amp; c_1 &amp; c_2 &amp; \cdots &amp; c_{n-1} \\
c_{n-1} &amp; c_0 &amp; c_1 &amp; \cdots &amp; c_{n-2} \\
c_{n-2} &amp; c_{n-1} &amp; c_0 &amp; \cdots &amp; c_{n-3} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
c_1 &amp; c_2 &amp; c_3 &amp; \cdots &amp; c_0
\end{pmatrix} = (c_{j-i \mod n})
\]</span></p>
<p>The base vector <span class="math inline">\(c\)</span> completely determines the circulant matrix and plays a crucial role in efficient computations. In particular:</p>
<ol type="1">
<li><p>The eigenvalues of <span class="math inline">\(C\)</span> are given by the Discrete Fourier Transform (DFT) of <span class="math inline">\(c\)</span>: <span class="math display">\[
\lambda_k = \sum_{j=0}^{n-1} c_j e^{-2\pi i jk/n}, \quad k = 0, 1, ..., n-1
\]</span></p></li>
<li><p>Matrix-vector multiplication can be performed using the FFT: <span class="math display">\[
Cv = \frac1n\text{DFT}(\text{DFT}(c) \odot \text{IDFT}(v))
\]</span></p></li>
<li><p>The determinant of <span class="math inline">\(C\)</span> is the product of its eigenvalues: <span class="math display">\[
\det(C) = \prod_{k=0}^{n-1} \lambda_k
\]</span></p></li>
<li><p>When <span class="math inline">\(C\)</span> is non singular, then the inverse is circulant and thus determined by its base:</p></li>
</ol>
<p><span class="math display">\[
\frac1n \text{IDFT}(\text{DFT}(c)^{-1}).
\]</span></p>
<p>These properties allow for much faster computations than for general matrices.</p>
</section>
<section id="block-circulant-matrices" class="level3">
<h3 class="anchored" data-anchor-id="block-circulant-matrices">Block Circulant Matrices</h3>
<p>For two-dimensional spatial fields, we use block circulant matrices with circulant blocks (BCCB). An <span class="math inline">\(Nn \times Nn\)</span> matrix C is block circulant if it has the form:</p>
<p><span class="math display">\[
C = \begin{pmatrix}
C_0 &amp; C_1 &amp; C_2 &amp; \cdots &amp; C_{N-1} \\
C_{N-1} &amp; C_0 &amp; C_1 &amp; \cdots &amp; C_{N-2} \\
C_{N-2} &amp; C_{N-1} &amp; C_0 &amp; \cdots &amp; C_{N-3} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
C_1 &amp; C_2 &amp; C_3 &amp; \cdots &amp; C_0
\end{pmatrix} = (C_{j-i \mod N})
\]</span></p>
<p>where each <span class="math inline">\(C_i\)</span> is itself a circulant <span class="math inline">\(n \times n\)</span> matrix.</p>
<p>For a BCCB matrix, we define a base matrix <span class="math inline">\(\mathbf c\)</span>, which is an <span class="math inline">\(n \times N\)</span> matrix where each column is the base vector of the corresponding circulant block. This base matrix <span class="math inline">\(\mathbf c\)</span> completely determines the BCCB matrix and is central to efficient computations:</p>
<ol type="1">
<li><p>The eigenvalues of <span class="math inline">\(C\)</span> are given by the 2D DFT of <span class="math inline">\(\mathbf c\)</span>: <span class="math display">\[
\Lambda_{k,l} = \sum_{i=0}^{n-1} \sum_{j=0}^{N-1} c_{ij} e^{-2\pi i (ki/n + lj/N)}, \quad k = 0, \dots, n-1, l = 0, \dots, N-1
\]</span></p></li>
<li><p>Matrix-vector multiplication can be performed using the 2D FFT: <span class="math display">\[
Cv = \text{IDFT2}(\text{DFT2}(c) \odot \text{DFT2}(v))
\]</span></p></li>
<li><p>The determinant of <span class="math inline">\(C\)</span> is the product of its eigenvalues: <span class="math display">\[
\det(C) = \prod_{k=0}^{n-1} \prod_{l=0}^{N-1} \Lambda_{k,l}
\]</span></p></li>
</ol>
</section>
<section id="computational-advantages" class="level3">
<h3 class="anchored" data-anchor-id="computational-advantages">Computational Advantages</h3>
<p>The circulant structure allows for efficient computation using the Fast Fourier Transform (FFT):</p>
<ol type="1">
<li><p>Matrix-vector multiplication: For a circulant matrix C with base c and a vector v <span class="math display">\[
Cv = \sqrt{n} \text{DFT}(\text{DFT}(c) \odot \text{IDFT}(v)),
\]</span></p></li>
<li><p>Matrix inverse: The base of <span class="math inline">\(C^{-1}\)</span> is given by <span class="math display">\[
\frac{1}{n} \text{IDFT}(\text{DFT}(c)^{-1}).
\]</span></p></li>
</ol>
</section>
<section id="approximations-for-q1" class="level3">
<h3 class="anchored" data-anchor-id="approximations-for-q1">Approximations for Q1</h3>
<p>Let <span class="math inline">\(Q_1\)</span> be the precision matrix of a one-dimensional AR(1) process with n observations. The exact form of <span class="math inline">\(Q_1\)</span> is:</p>
<p><span class="math display">\[
\mathbf{Q}_1 = \frac{1}{1-\rho^2}
\begin{bmatrix}
1 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1
\end{bmatrix}
\]</span></p>
<section id="circulant-approximation" class="level4">
<h4 class="anchored" data-anchor-id="circulant-approximation">Circulant Approximation</h4>
<p>The circulant approximation to <span class="math inline">\(Q_1\)</span>, denoted as <span class="math inline">\(\mathbf{Q}_1^{(circ)}\)</span>, is:</p>
<p><span class="math display">\[
\mathbf{Q}_1^{(circ)} = \frac{1}{1-\rho^2}
\begin{bmatrix}
1+\rho^2 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; -\rho \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
-\rho &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho &amp; 1+\rho^2
\end{bmatrix}
\]</span></p>
<p>This approximation treats the first and last observations as neighbors, effectively wrapping the data around a circle.</p>
</section>
<section id="folded-circulant-approximation" class="level4">
<h4 class="anchored" data-anchor-id="folded-circulant-approximation">Folded Circulant Approximation</h4>
<p>The folded circulant approximation, <span class="math inline">\(\mathbf{Q}_1^{(fold)}\)</span>, is based on a reflected version of the data. We double the data by reflecting it, giving us the data <span class="math inline">\(x_1,  \dots, x_n, x_n, \dots, x_1\)</span>. We then model this doubled data with a <span class="math inline">\(2n \times 2n\)</span> circulant matrix. If written out as an <span class="math inline">\(n \times n\)</span> matrix, it takes the form:</p>
<p><span class="math display">\[
\mathbf{Q}_1^{(fold)} = \frac{1}{1-\rho^2}
\begin{bmatrix}
1-\rho+\rho^2 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho &amp; 1-\rho+\rho^2
\end{bmatrix}
\]</span></p>
<p>This approximation modifies the first and last diagonal elements to account for the reflection of the data. As <span class="math inline">\(x_1\)</span> now is the first and last data point, then we avoid the circular dependence from the regular circulant approximation.</p>
</section>
</section>
<section id="extension-to-the-full-q-matrix" class="level3">
<h3 class="anchored" data-anchor-id="extension-to-the-full-q-matrix">Extension to the Full Q Matrix</h3>
<p>For a two-dimensional spatial field on an <span class="math inline">\(n \times n\)</span> grid, we construct the full precision matrix Q using a Kronecker sum:</p>
<p><span class="math display">\[
\mathbf{Q} = (\mathbf{Q}_1 \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{Q}_1)^{(\nu + 1)}
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, I is the <span class="math inline">\(n \times n\)</span> identity matrix, and <span class="math inline">\(\nu\)</span> is a smoothness parameter.</p>
<p>When we approximate <span class="math inline">\(Q_1\)</span> with a circulant matrix, this Kronecker sum results in a block-circulant matrix with circulant blocks (BCCB). To see this, let’s consider the case where <span class="math inline">\(\nu = 0\)</span> for simplicity:</p>
<p><span class="math display">\[
\mathbf{Q} = \mathbf{Q}_1 \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{Q}_1
\]</span></p>
<p>Now, let <span class="math inline">\(Q_1\)</span> be approximated by a circulant matrix C with base vector <span class="math inline">\(c = [c_, c_1, ..., c_{n-1}]\)</span>. Then:</p>
<p><span class="math display">\[
\mathbf{Q}_1 \approx \mathbf{C} =
\begin{pmatrix}
c_0 &amp; c_1 &amp; \cdots &amp; c_{n-1} \\
c_{n-1} &amp; c_0 &amp; \cdots &amp; c_{n-2} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
c_1 &amp; c_2 &amp; \cdots &amp; c_0
\end{pmatrix}
\]</span></p>
<p>The Kronecker product <span class="math inline">\(C \otimes I\)</span> results in a block matrix where each block is a scalar multiple of I:</p>
<p><span class="math display">\[
\mathbf{C} \otimes \mathbf{I} =
\begin{pmatrix}
c_0\mathbf{I} &amp; c_1\mathbf{I} &amp; \cdots &amp; c_{n-1}\mathbf{I} \\
c_{n-1}\mathbf{I} &amp; c_0\mathbf{I} &amp; \cdots &amp; c_{n-2}\mathbf{I} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
c_1\mathbf{I} &amp; c_2\mathbf{I} &amp; \cdots &amp; c_0\mathbf{I}
\end{pmatrix}
\]</span></p>
<p>Similarly, I ⊗ C results in a block matrix where each block is a copy of C:</p>
<p><span class="math display">\[
\mathbf{I} \otimes \mathbf{C} =
\begin{pmatrix}
\mathbf{C} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \\
\mathbf{0} &amp; \mathbf{C} &amp; \cdots &amp; \mathbf{0} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{C}
\end{pmatrix}
\]</span></p>
<p>The sum of these two matrices is a block-circulant matrix with circulant blocks:</p>
<p><span class="math display">\[
\mathbf{Q} \approx \mathbf{C} \otimes \mathbf{I} + \mathbf{I} \otimes \mathbf{C} =
\begin{pmatrix}
\mathbf{B}_0 &amp; \mathbf{B}_1 &amp; \cdots &amp; \mathbf{B}_{n-1} \\
\mathbf{B}_{n-1} &amp; \mathbf{B}_0 &amp; \cdots &amp; \mathbf{B}_{n-2} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mathbf{B}_1 &amp; \mathbf{B}_2 &amp; \cdots &amp; \mathbf{B}_0
\end{pmatrix}
\]</span></p>
<p>where each <span class="math inline">\(\mathbf{B_i}\)</span> is a circulant matrix. Specifically, <span class="math inline">\(\mathbf{B_0} = c_0I + C\)</span>, and for <span class="math inline">\(i \neq 0\)</span>, <span class="math inline">\(\mathbf{B_i} = c_iI\)</span>.</p>
<p>This BCCB structure allows us to use 2D FFT for efficient computations. The base matrix <span class="math inline">\(\mathbf c\)</span> for this BCCB structure is:</p>
<p><span class="math display">\[
\mathbf{c} = \begin{bmatrix}
2+2\rho^2 &amp; -\rho &amp; 0 &amp; \cdots  &amp; -\rho \\
-\rho &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;  \vdots \\
-\rho &amp; 0 &amp; 0 &amp; \cdots  &amp; 0
\end{bmatrix}
\]</span></p>
<p>This base matrix <span class="math inline">\(c\)</span> captures the structure of the precision matrix <span class="math inline">\(Q\)</span> and allows for efficient computation of eigenvalues using the 2D Fast Fourier Transform (FFT), enabling rapid calculation of the log-determinant and quadratic forms needed for the Gaussian copula density.</p>
</section>
</section>
<section id="computation-with-circulant-approximation" class="level2">
<h2 class="anchored" data-anchor-id="computation-with-circulant-approximation">Computation with Circulant Approximation</h2>
<p>When using the circulant approximation, we leverage the efficient computation properties of block circulant matrices with circulant blocks (BCCB). This approach significantly reduces the computational complexity, especially for large spatial fields. Here’s the step-by-step process:</p>
<section id="construct-the-base-matrix" class="level3">
<h3 class="anchored" data-anchor-id="construct-the-base-matrix">1. Construct the Base Matrix</h3>
<p>First, we construct the base matrix c for our BCCB approximation of Q. For an n × n grid, c is an n × n matrix:</p>
<p><span class="math display">\[
\mathbf{c} = \begin{bmatrix}
2+2\rho^2 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; -\rho \\
-\rho &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
-\rho &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>This base matrix encapsulates the structure of our Matérn-like precision matrix.</p>
</section>
<section id="compute-initial-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="compute-initial-eigenvalues">2. Compute Initial Eigenvalues</h3>
<p>We compute the initial eigenvalues of Q using the 2D Fast Fourier Transform (FFT) of c:</p>
<p><span class="math display">\[
\boldsymbol{\Lambda} = \text{FFT2}(\mathbf{c})^{\nu+1}
\]</span></p>
<p>where ν is the smoothness parameter.</p>
</section>
<section id="compute-marginal-variance-and-rescale-eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="compute-marginal-variance-and-rescale-eigenvalues">3. Compute Marginal Variance and Rescale Eigenvalues</h3>
<p>An important property of Block Circulant with Circulant Blocks (BCCB) matrices is that the inverse of a BCCB matrix is also a BCCB matrix with a constant diagonal. We use this to efficiently compute the marginal variance and rescale the eigenvalues:</p>
<ol type="a">
<li>Compute the element-wise inverse of <span class="math inline">\(\boldsymbol{\Lambda}\)</span>: <span class="math inline">\(\mathbf{\Lambda^{inv}} = 1 / \boldsymbol{\Lambda}\)</span></li>
<li>Compute the base of <span class="math inline">\(Q^{-1}\)</span> using inverse 2D FFT: <span class="math inline">\(\mathbf{c_{inv}} = \text{IFFT2}(\mathbf{{\Lambda^{inv}}})\)</span></li>
<li>The marginal variance is given by the first element of <span class="math inline">\(\mathbf{c^{inv}}\)</span>: <span class="math inline">\(\sigma^2 = \mathbf{c^{inv}}_{(0,0)}\)</span></li>
<li>Rescale the eigenvalues: <span class="math inline">\(\boldsymbol{\widetilde \Lambda} = \sigma^2 \boldsymbol{\Lambda}\)</span></li>
</ol>
<p>This process ensures that the resulting precision matrix will have unit marginal variances, as required for the Gaussian copula.</p>
</section>
<section id="compute-log-determinant" class="level3">
<h3 class="anchored" data-anchor-id="compute-log-determinant">4. Compute Log-Determinant</h3>
<p>The log-determinant of the scaled <span class="math inline">\(\mathbf{\widetilde Q}\)</span> can be efficiently calculated as the sum of the logarithms of the scaled eigenvalues:</p>
<p><span class="math display">\[
\log|\mathbf{Q}| = \sum_{i,j} \log(\widetilde \Lambda_{ij})
\]</span></p>
</section>
<section id="compute-quadratic-form" class="level3">
<h3 class="anchored" data-anchor-id="compute-quadratic-form">5. Compute Quadratic Form</h3>
<p>To compute the quadratic form <span class="math inline">\(\mathbf{z}^T\mathbf{Q}\mathbf{z}\)</span>, we use the following steps:</p>
<ol type="a">
<li>Compute the 2D FFT of z: <span class="math inline">\(\mathbf{\hat{z}} = \text{FFT2}(\mathbf{z})\)</span></li>
<li>Multiply element-wise with the scaled eigenvalues: <span class="math inline">\(\mathbf{\hat{y}} = \boldsymbol{\widetilde \Lambda} \odot \mathbf{\hat{z}}\)</span></li>
<li>Compute the inverse 2D FFT: <span class="math inline">\(\mathbf{y} = \text{IFFT2}(\mathbf{\hat{y}})\)</span></li>
<li>Compute the dot product: <span class="math inline">\(\mathbf{z}^T\mathbf{Q}\mathbf{z} = \mathbf{z}^T\mathbf{y}\)</span></li>
</ol>
</section>
<section id="compute-the-log-density" class="level3">
<h3 class="anchored" data-anchor-id="compute-the-log-density">6. Compute the Log-Density</h3>
<p>Finally, we can compute the log-density of the Gaussian copula:</p>
<p><span class="math display">\[
\log c(\mathbf{u}) = \frac{1}{2}\log|\mathbf{Q}| - \frac{1}{2}\mathbf{z}^T\mathbf{Q}\mathbf{z} + \frac{1}{2}\mathbf{z}^T\mathbf{z}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{z} = \Phi^{-1}(\mathbf{u})\)</span>.</p>
</section>
</section>
<section id="computation-with-folded-circulant-approximation" class="level2">
<h2 class="anchored" data-anchor-id="computation-with-folded-circulant-approximation">Computation with Folded Circulant Approximation</h2>
<p>The folded circulant approximation offers an alternative approach that can provide better accuracy near the edges of the spatial field. This method is based on the idea of reflecting the data along each coordinate axis, effectively doubling the size of the field. Other than that, the algorithmic implementation is the same except that the circulant approximation matrices to <span class="math inline">\(Q_1\)</span> are now <span class="math inline">\(2n \times 2n\)</span>.</p>
<p>First, we reflect the data along each coordinate axis. For a 2D spatial field represented by an <span class="math inline">\(n \times n\)</span> matrix, the reflected data takes the form:</p>
<p><span class="math display">\[
\begin{bmatrix}
x_{11} &amp; \cdots &amp; x_{1n} &amp; x_{1n} &amp; \cdots &amp; x_{11} \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; \cdots &amp; x_{nn} &amp; x_{nn} &amp; \cdots &amp; x_{n1} \\
x_{n1} &amp; \cdots &amp; x_{nn} &amp; x_{nn} &amp; \cdots &amp; x_{n1} \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{11} &amp; \cdots &amp; x_{1n} &amp; x_{1n} &amp; \cdots &amp; x_{11}
\end{bmatrix}
\]</span></p>
<p>This reflection creates a <span class="math inline">\(2n \times 2n\)</span> matrix. The matrix is then stacked in lexicographic order before entering into the quadratic forms.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<section id="computational-efficiency" class="level2">
<h2 class="anchored" data-anchor-id="computational-efficiency">Computational Efficiency</h2>
<p>Table 1 presents the results of a benchmark comparing the time it takes to evaluate the gaussian copula density described above. For each grid size, we report the computation time for the exact method and the two approximations, along with the speed-up factor relative to the exact method. Each calculation was performed twenty times and the median times are shown in the table.</p>
<table class="caption-top table">
<caption>Table 1. Benchmarking how long it takes to evaluate the density of a Mátern(<span class="math inline">\(\nu\)</span>)-like field with correlation parameter <span class="math inline">\(\rho\)</span>, scaled to have unit marginal variance.</caption>
<thead>
<tr class="header">
<th>Q_size</th>
<th>Exact</th>
<th>Circulant</th>
<th></th>
<th>Folded</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>Time</td>
<td>Time</td>
<td>Speed-Up</td>
<td>Time</td>
<td>Speed-Up</td>
</tr>
<tr class="even">
<td>100x100</td>
<td>194.69μs</td>
<td>33.89μs</td>
<td>5.75x</td>
<td>44.77μs</td>
<td>4.35x</td>
</tr>
<tr class="odd">
<td>400x400</td>
<td>309.61μs</td>
<td>37.45μs</td>
<td>8.27x</td>
<td>122.78μs</td>
<td>2.52x</td>
</tr>
<tr class="even">
<td>900x900</td>
<td>790.30μs</td>
<td>85.65μs</td>
<td>9.23x</td>
<td>155.47μs</td>
<td>5.08x</td>
</tr>
<tr class="odd">
<td>1600x1600</td>
<td>1.96ms</td>
<td>98.71μs</td>
<td>19.86x</td>
<td>243.64μs</td>
<td>8.05x</td>
</tr>
<tr class="even">
<td>3600x3600</td>
<td>8.66ms</td>
<td>151.70μs</td>
<td>57.1x</td>
<td>484.07μs</td>
<td>17.89x</td>
</tr>
<tr class="odd">
<td>10000x10000</td>
<td>71.81ms</td>
<td>343.07μs</td>
<td>209.31x</td>
<td>1.36ms</td>
<td>52.76x</td>
</tr>
<tr class="even">
<td>19600x19600</td>
<td>246.40ms</td>
<td>667.58μs</td>
<td>369.09x</td>
<td>2.89ms</td>
<td>85.32x</td>
</tr>
<tr class="odd">
<td>40000x40000</td>
<td>997.32ms</td>
<td>1.44ms</td>
<td>694.46x</td>
<td>7.69ms</td>
<td>129.69x</td>
</tr>
</tbody>
</table>
<p>The results demonstrate significant computational gains from both approximation methods, with the efficiency advantage increasing for larger grid sizes. Key observations include:</p>
<ol type="1">
<li><p><strong>Scalability</strong>: Both approximation methods show superior scalability compared to the exact method. As the grid size increases, the speed-up factor generally increases, indicating that the approximations become increasingly advantageous for larger spatial fields.</p></li>
<li><p><strong>Circulant Approximation Performance</strong>: The circulant approximation consistently outperforms the folded circulant approximation in terms of speed. For the largest grid size (40000x40000), it achieves a remarkable 694.46x speed-up over the exact method.</p></li>
<li><p><strong>Folded Circulant Approximation</strong>: While not as fast as the circulant approximation, the folded circulant method still offers substantial speed improvements, reaching a 129.69x speed-up for the 40000x40000 grid.</p></li>
<li><p><strong>Trade-off Considerations</strong>: The choice between the circulant and folded circulant approximations may depend on the specific requirements of the application. While the circulant approximation is faster, the folded circulant method may offer better accuracy, particularly near the edges of the spatial field.</p></li>
</ol>
<p>These results underscore the practical value of our approximation methods, especially for large-scale spatial analyses where computational efficiency is crucial. The substantial speed-ups achieved, particularly for larger grids, demonstrate the potential of these methods to enable the analysis of much larger spatial datasets than previously feasible with exact methods.</p>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="appendix" class="level1 appendix"><h2 class="anchored quarto-appendix-heading">Appendix</h2><div class="quarto-appendix-contents">

<section id="cholesky-methods" class="level2">
<h2 class="anchored" data-anchor-id="cholesky-methods">Cholesky Methods</h2>
<p>Standard methods of evaluating multivariate normal densities using the Cholesky decomposition were implemented to compare with the new methods for benchmarking.</p>
<section id="unscaled-precision-matrix" class="level3">
<h3 class="anchored" data-anchor-id="unscaled-precision-matrix">Unscaled Precision Matrix</h3>
<section id="precision-matrix-construction" class="level4">
<h4 class="anchored" data-anchor-id="precision-matrix-construction">Precision Matrix Construction</h4>
<p>We start by constructing the precision matrix <span class="math inline">\(Q\)</span> for a 2D Matérn field on a grid of size <span class="math inline">\(d_x \times d_y\)</span>:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, <span class="math inline">\(Q_1\)</span> and <span class="math inline">\(Q_2\)</span> are 1D precision matrices for the x and y dimensions respectively (typically AR(1)-like structures), and <span class="math inline">\(I_{d_x}\)</span> and <span class="math inline">\(I_{d_y}\)</span> are identity matrices of appropriate sizes.</p>
</section>
<section id="cholesky-decomposition" class="level4">
<h4 class="anchored" data-anchor-id="cholesky-decomposition">Cholesky Decomposition</h4>
<p>We compute the Cholesky decomposition of <span class="math inline">\(Q\)</span>: <span class="math display">\[
Q = LL^T
\]</span></p>
<p>where L is a lower triangular matrix.</p>
</section>
<section id="density-computation" class="level4">
<h4 class="anchored" data-anchor-id="density-computation">Density Computation</h4>
<p>For a Matérn field with smoothness parameter <span class="math inline">\(\nu\)</span>, we need to work with <span class="math inline">\(Q^{\nu+1}\)</span>. The key insight is that we can efficiently compute log-determinant, <span class="math inline">\(\log|Q^{\nu+1}|\)</span>, and the quadratic form, <span class="math inline">\(x^T Q^{\nu+1} x\)</span>, without explicitly forming <span class="math inline">\(Q^{\nu+1}\)</span>. We make use of the facts that</p>
<p><span class="math display">\[
\log|Q^{\nu+1}| = (\nu+1)\log|Q| = 2(\nu+1)\sum_{i}\log(L_{ii}),
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\begin{aligned}
x^T Q x &amp;= x^T L L^T x = ||L^T x||_2^2 \\
x^T Q^2 x &amp;=  x^T L L^T L L^T x = ||LL^T x||_2^2 \\
x^T Q^3 x &amp;=  x^T L L^T L L^T L L^T x = ||L^TLL^T x||_2^2,
\end{aligned}
\]</span></p>
<p>to efficiently calculate the quadratic form using only the Cholesky factor of <span class="math inline">\(Q\)</span> instead of forming the matrix <span class="math inline">\(Q^\nu\)</span>.</p>
</section>
<section id="algorithm" class="level4">
<h4 class="anchored" data-anchor-id="algorithm">Algorithm</h4>
<ol type="1">
<li>Construct <span class="math inline">\(Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2\)</span></li>
<li>Compute Cholesky decomposition <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute log-determinant: <span class="math inline">\(\log|Q^{\nu+1}| = 2(\nu+1)\sum_{i}\log(L_{ii})\)</span></li>
<li>For each observation <span class="math inline">\(x\)</span>:
<ol type="i">
<li>Initialize <span class="math inline">\(y = x\)</span></li>
<li>For <span class="math inline">\(j\)</span> from 0 to <span class="math inline">\(\nu\)</span>:
<ul>
<li>If <span class="math inline">\(j\)</span> is even: <span class="math inline">\(y = L^T y\)</span></li>
<li>If <span class="math inline">\(j\)</span> is odd: <span class="math inline">\(y = L y\)</span></li>
</ul></li>
<li>Compute quadratic form <span class="math inline">\(q = y^Ty\)</span></li>
</ol></li>
<li>Compute log-density: <span class="math inline">\(\log p(x) = -\frac{1}{2}(d\log(2\pi) + \log|Q^{\nu+1}| + q)\)</span></li>
</ol>
</section>
</section>
<section id="scaled-precision-matrix" class="level3">
<h3 class="anchored" data-anchor-id="scaled-precision-matrix">Scaled Precision Matrix</h3>
<section id="precision-matrix-construction-1" class="level4">
<h4 class="anchored" data-anchor-id="precision-matrix-construction-1">Precision Matrix Construction</h4>
<p>We start by constructing the precision matrix <span class="math inline">\(Q\)</span> for a 2D Matérn field on a grid of size <span class="math inline">\(d_x \times d_y\)</span>:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> denotes the Kronecker product, <span class="math inline">\(Q_1\)</span> and <span class="math inline">\(Q_2\)</span> are 1D precision matrices for the x and y dimensions respectively (typically AR(1)-like structures), and <span class="math inline">\(I_{d_x}\)</span> and <span class="math inline">\(I_{d_y}\)</span> are identity matrices of appropriate sizes. We will then have to work with the matrix <span class="math inline">\(Q^{\nu + 1}\)</span>.</p>
<p>To ensure unit marginal variances, we need to scale this precision matrix. Let <span class="math inline">\(D\)</span> be a diagonal matrix where <span class="math inline">\(D_{ii} = \sqrt{\Sigma_{ii}}\)</span>, and <span class="math inline">\(\Sigma = (Q^{\nu+1})^{-1}\)</span>. The scaled precision matrix is then: <span class="math display">\[
\tilde{Q} = DQ^{\nu+1}D
\]</span></p>
</section>
<section id="cholesky-decomposition-1" class="level4">
<h4 class="anchored" data-anchor-id="cholesky-decomposition-1">Cholesky Decomposition</h4>
<p>We compute the Cholesky decomposition of <span class="math inline">\(Q\)</span>: <span class="math display">\[
Q = LL^T
\]</span></p>
<p>where L is a lower triangular matrix.</p>
</section>
<section id="efficient-computation-of-scaling-matrix-d" class="level4">
<h4 class="anchored" data-anchor-id="efficient-computation-of-scaling-matrix-d">Efficient Computation of Scaling Matrix D</h4>
<p>Computing <span class="math inline">\(D\)</span> directly would require inverting <span class="math inline">\(Q^{\nu + 1}\)</span>, which is computationally expensive. Instead, we can efficiently compute <span class="math inline">\(D\)</span> using the following steps:</p>
<ol type="1">
<li>Compute the Cholesky decomposition of the original <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute <span class="math inline">\(R = L^{-1}\)</span>, so that <span class="math inline">\(S = Q^{-1} = R^TR\)</span>.</li>
<li>We then calculate the entries in <span class="math inline">\(D\)</span> using the following steps:
<ol type="i">
<li>For <span class="math inline">\(\nu = 0\)</span>, <span class="math inline">\(D_{ii} = \sqrt{\Sigma_{ii}} = \sqrt{\sum_j (R_{ji})^2}\)</span>, the column-wise norm of <span class="math inline">\(R\)</span>.</li>
<li>For <span class="math inline">\(\nu = 1\)</span>, we use the column-wise norm of <span class="math inline">\(R^TR\)</span></li>
<li>For <span class="math inline">\(\nu = 2\)</span>, we use the column-wise norm of <span class="math inline">\(RR^TR\)</span></li>
</ol></li>
</ol>
<p>This gives us the matrix D without having to explicitly invert the matrix Q.</p>
</section>
<section id="log-determinant" class="level4">
<h4 class="anchored" data-anchor-id="log-determinant">Log determinant</h4>
<p>The log determinant of the scaled precision matrix <span class="math inline">\(\tilde{Q} = DQ^{\nu+1}D\)</span> can be computed efficiently using the following steps:</p>
<ol type="1">
<li>First, note that <span class="math inline">\(\log|\tilde{Q}| = \log|DQ^{\nu+1}D| = 2\log|D| + \log|Q^{\nu+1}|\)</span></li>
<li>We can compute <span class="math inline">\(\log|D|\)</span> directly from the diagonal elements of D, i.e.&nbsp;<span class="math inline">\(\log|D| = \sum_i \log(D_{ii})\)</span></li>
<li>For <span class="math inline">\(\log|Q^{\nu+1}|\)</span>, we can use the properties of the Cholesky decomposition: <span class="math inline">\(\log|Q^{\nu+1}| = (\nu+1)\log|Q| = (\nu+1)\log|LL^T| = 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
<li>Combining these, we get <span class="math inline">\(\log|\tilde{Q}| = 2\sum_i \log(D_{ii}) + 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
</ol>
<p>This allows us to compute the log determinant efficiently without explicitly forming <span class="math inline">\(Q^{\nu+1}\)</span> or its inverse.</p>
</section>
<section id="quadratic-form" class="level4">
<h4 class="anchored" data-anchor-id="quadratic-form">Quadratic Form</h4>
<p>For the quadratic form <span class="math inline">\(z^T\tilde{Q}z\)</span>, where <span class="math inline">\(z = \Phi^{-1}(u)\)</span>, we can use the following steps:</p>
<ol type="1">
<li>First, note that <span class="math inline">\(z^T\tilde{Q}z = z^TDQ^{\nu+1}Dz = (Dz)^TQ^{\nu+1}(Dz)\)</span></li>
<li>Let <span class="math inline">\(y = Dz\)</span>. We can compute this element-wise as <span class="math inline">\(y_i = D_{ii}z_i\)</span></li>
<li>Now we need to compute <span class="math inline">\(y^TQ^{\nu+1}y\)</span>. We can do this efficiently using the Cholesky factor L:
<ol type="i">
<li>For <span class="math inline">\(\nu = 0\)</span>: <span class="math inline">\(y^TQy = ||L^Ty||_2^2\)</span></li>
<li>For <span class="math inline">\(\nu = 1\)</span>: <span class="math inline">\(y^TQ^2y = ||LL^Ty||_2^2\)</span></li>
<li>For <span class="math inline">\(\nu = 2\)</span>: <span class="math inline">\(y^TQ^3y = ||L^TLL^Ty||_2^2\)</span></li>
</ol></li>
<li>In general, we can compute this as follows:
<ol type="i">
<li>Initialize <span class="math inline">\(y = Dz\)</span></li>
<li>For j from 0 to <span class="math inline">\(\nu\)</span>:
<ul>
<li>If j is even: <span class="math inline">\(y = L^Ty\)</span></li>
<li>If j is odd: <span class="math inline">\(y = Ly\)</span></li>
</ul></li>
<li>Compute quadratic form <span class="math inline">\(q = y^Ty\)</span></li>
</ol></li>
</ol>
<p>This approach allows us to compute the quadratic form efficiently without explicitly forming <span class="math inline">\(Q^{\nu+1}\)</span>.</p>
</section>
<section id="algorithm-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-1">Algorithm</h4>
<p>Putting it all together, here’s the algorithm for computing the log-density of the Gaussian copula using the scaled precision matrix:</p>
<ol type="1">
<li>Construct <span class="math inline">\(Q = Q_1 \otimes I_{d_y} + I_{d_x} \otimes Q_2\)</span></li>
<li>Compute Cholesky decomposition <span class="math inline">\(Q = LL^T\)</span></li>
<li>Compute <span class="math inline">\(R = L^{-1}\)</span> and use it to compute D as described earlier</li>
<li>Compute log-determinant: <span class="math inline">\(\log|\tilde{Q}| = 2\sum_i \log(D_{ii}) + 2(\nu+1)\sum_i \log(L_{ii})\)</span></li>
<li>For each observation <span class="math inline">\(z = \Phi^{-1}(u)\)</span>:
<ol type="i">
<li>Compute <span class="math inline">\(y = Dz\)</span></li>
<li>For j from 0 to <span class="math inline">\(\nu\)</span>:
<ul>
<li>If j is even: <span class="math inline">\(y = L^Ty\)</span></li>
<li>If j is odd: <span class="math inline">\(y = Ly\)</span></li>
</ul></li>
<li>Compute quadratic form <span class="math inline">\(q = y^Ty\)</span></li>
</ol></li>
<li>Compute log-density: <span class="math inline">\(\log c(u) = -\frac{1}{2}(d\log(2\pi) + \log|\tilde{Q}| + q - z^Tz)\)</span></li>
</ol>
<p>This algorithm computes the Gaussian copula density using the scaled precision matrix, avoiding explicit formation or inversion of <span class="math inline">\(\tilde Q = DQ^{\nu + 1}D\)</span>.</p>
</section>
</section>
</section>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>