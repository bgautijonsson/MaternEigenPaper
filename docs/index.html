<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="dcterms.date" content="2024-07-24">

<title>Bridging Gaussian Markov Random Fields and Copulas: A Fast Algorithm for Efficient Gaussian Copula Density Computation with Matérn-like Precision Matrices</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Bridging Gaussian Markov Random Fields and Copulas: A Fast Algorithm for Efficient Gaussian Copula Density Computation with Matérn-like Precision Matrices">
<meta name="citation_abstract" content="Gaussian Markov Random Fields (GMRFs) have long been a powerful tool for modeling spatial and temporal dependencies in various fields. Similarly, copulas have proven invaluable for modeling complex dependency structures in multivariate data. However, the combination of these two approaches - using GMRFs within copula models - has historically been computationally inefficient, limiting their joint application to smaller datasets or simpler models. This work presents a novel algorithm that overcomes these limitations, allowing for fast and efficient computation of Gaussian Copula densities using GMRF precision structures. By bridging the gap between GMRFs and copulas, this method opens up new possibilities for analyzing large-scale, high-dimensional spatial and spatio-temporal data with complex dependency structures.">
<meta name="citation_author" content="Brynjólfur Gauti Guðrúnar Jónsson">
<meta name="citation_publication_date" content="2024-07-24">
<meta name="citation_cover_date" content="2024-07-24">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-07-24">
<meta name="citation_language" content="en">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Bridging Gaussian Markov Random Fields and Copulas: A Fast Algorithm for Efficient Gaussian Copula Density Computation with Matérn-like Precision Matrices</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
            <div class="quarto-title-meta-author">
          <div class="quarto-title-meta-heading">Author</div>
          <div class="quarto-title-meta-heading">Affiliation</div>
          
                <div class="quarto-title-meta-contents">
            <p class="author"><a href="bggj.is">Brynjólfur Gauti Guðrúnar Jónsson</a> <a href="mailto:brynjolfur@hi.is" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
                <div class="quarto-title-meta-contents">
                    <p class="affiliation">
                        University of Iceland
                      </p>
                  </div>
                    </div>
        
        <div class="quarto-title-meta">

                      
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">July 24, 2024</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      <div class="quarto-alternate-formats"><div class="quarto-title-meta-heading">Other Formats</div><div class="quarto-title-meta-contents"><p><a href="index.docx"><i class="bi bi-file-word"></i>MS Word</a></p></div><div class="quarto-title-meta-contents"><p><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF (acs)</a></p></div><div class="quarto-title-meta-contents"><p><a href="index-meca.zip" data-meca-link="true"><i class="bi bi-archive"></i>MECA Bundle</a></p></div></div></div>
    </div>

    <div>
      <div class="abstract">
        <div class="block-title">Abstract</div>
        Gaussian Markov Random Fields (GMRFs) have long been a powerful tool for modeling spatial and temporal dependencies in various fields. Similarly, copulas have proven invaluable for modeling complex dependency structures in multivariate data. However, the combination of these two approaches - using GMRFs within copula models - has historically been computationally inefficient, limiting their joint application to smaller datasets or simpler models. This work presents a novel algorithm that overcomes these limitations, allowing for fast and efficient computation of Gaussian Copula densities using GMRF precision structures. By bridging the gap between GMRFs and copulas, this method opens up new possibilities for analyzing large-scale, high-dimensional spatial and spatio-temporal data with complex dependency structures.
      </div>
    </div>


    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#gmrf-copula" id="toc-gmrf-copula" class="nav-link" data-scroll-target="#gmrf-copula">GMRF Copula</a></li>
  <li><a href="#theory" id="toc-theory" class="nav-link" data-scroll-target="#theory">Theory</a></li>
  <li><a href="#one-dimensional-ar1-matrix" id="toc-one-dimensional-ar1-matrix" class="nav-link" data-scroll-target="#one-dimensional-ar1-matrix">One-Dimensional AR(1) Matrix</a></li>
  <li><a href="#matérn-like-precision-matrix" id="toc-matérn-like-precision-matrix" class="nav-link" data-scroll-target="#matérn-like-precision-matrix">Matérn-like Precision Matrix</a></li>
  <li><a href="#eigendecomposition-of-kronecker-sums" id="toc-eigendecomposition-of-kronecker-sums" class="nav-link" data-scroll-target="#eigendecomposition-of-kronecker-sums">Eigendecomposition of Kronecker Sums</a>
  <ul class="collapse">
  <li><a href="#theorem" id="toc-theorem" class="nav-link" data-scroll-target="#theorem">Theorem</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul></li>
  <li><a href="#example-calculating-eigenvalues-and-eigenvectors-for-q-using-q_1" id="toc-example-calculating-eigenvalues-and-eigenvectors-for-q-using-q_1" class="nav-link" data-scroll-target="#example-calculating-eigenvalues-and-eigenvectors-for-q-using-q_1">Example: Calculating Eigenvalues and Eigenvectors for <span class="math inline">\(Q\)</span> Using <span class="math inline">\(Q_1\)</span></a>
  <ul class="collapse">
  <li><a href="#eigenvalues" id="toc-eigenvalues" class="nav-link" data-scroll-target="#eigenvalues">Eigenvalues</a></li>
  <li><a href="#eigenvectors" id="toc-eigenvectors" class="nav-link" data-scroll-target="#eigenvectors">Eigenvectors</a></li>
  </ul></li>
  <li><a href="#efficient-density-calculation-using-eigendecomposition" id="toc-efficient-density-calculation-using-eigendecomposition" class="nav-link" data-scroll-target="#efficient-density-calculation-using-eigendecomposition">Efficient Density Calculation Using Eigendecomposition</a>
  <ul class="collapse">
  <li><a href="#log-determinant-calculation" id="toc-log-determinant-calculation" class="nav-link" data-scroll-target="#log-determinant-calculation">Log-Determinant Calculation</a></li>
  <li><a href="#quadratic-form-calculation" id="toc-quadratic-form-calculation" class="nav-link" data-scroll-target="#quadratic-form-calculation">Quadratic Form Calculation</a></li>
  <li><a href="#scaling-the-input-x" id="toc-scaling-the-input-x" class="nav-link" data-scroll-target="#scaling-the-input-x">Scaling the Input x</a></li>
  </ul></li>
  <li><a href="#algorithm-implementation" id="toc-algorithm-implementation" class="nav-link" data-scroll-target="#algorithm-implementation">Algorithm Implementation</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



  


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Gaussian Markov Random Fields (GMRFs) and Copulas are two powerful tools in modern statistics, each with their own strengths in modeling complex data structures. GMRFs have been widely used for modeling spatial and temporal dependencies, particularly in fields such as environmental science, epidemiology, and image analysis. Their ability to capture local dependencies through a sparse precision matrix makes them computationally attractive for high-dimensional problems.</p>
<p>Copulas, on the other hand, provide a flexible framework for modeling multivariate dependencies, allowing for the separate specification of marginal distributions and their joint behavior. The Gaussian copula, in particular, has gained popularity due to its interpretability and connection to the multivariate normal distribution.</p>
<p>Let <span class="math inline">\(\mathbf{X} = (X_1, X_2, \ldots, X_n)\)</span> be a multivariate random vector with marginal distribution functions <span class="math inline">\(F_i\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span> and dependence that is governed by a GMRF copula. The joint distribution function of <span class="math inline">\(\mathbf{X}\)</span> can be written as:</p>
<p><span class="math display">\[
F_{\mathbf{X}}(\mathbf{x}) = C(F_1(x_1), F_2(x_2), \ldots, F_n(x_n)),
\]</span></p>
<p>where <span class="math inline">\(C\)</span> is the Gaussian copula defined by the GMRF precision matrix <span class="math inline">\(Q\)</span>.</p>
<p>The Gaussian copula <span class="math inline">\(C\)</span> is given by:</p>
<p><span class="math display">\[
C(u_1, u_2, \ldots, u_n) = \Phi_Q(\Phi^{-1}(u_1), \Phi^{-1}(u_2), \ldots, \Phi^{-1}(u_n)),
\]</span></p>
<p>where <span class="math inline">\(\Phi_Q\)</span> is the joint cumulative distribution function of a multivariate normal distribution with mean vector <span class="math inline">\(\mathbf{0}\)</span> and precision matrix <span class="math inline">\(Q\)</span>, and <span class="math inline">\(\Phi^{-1}\)</span> is the inverse of the standard normal cumulative distribution function. Its density is</p>
<p>It is imperative that the precision matrix <span class="math inline">\(Q\)</span> governing the GMRF Copula, <span class="math inline">\(C\)</span>, has marginal variance equal to 1 so that is it on the same scale as the transformed data, <span class="math inline">\(\Phi^{-1}(u_i)\)</span>. This can be troublesome because GMRFs are defined in terms of their precision matrices, <span class="math inline">\(Q\)</span>, which more often than not have marginal variances that are different from 1.</p>
<p>This paper presents a fast and efficient algorithm for creating a Matérn-like precision matrix, <span class="math inline">\(\mathbf{Q}\)</span>, with unit marginal variance, and computing the multivariate Gaussian copula density of <span class="math inline">\(\mathbf{Z} = \Phi^{-1}(\mathbf{u})\)</span> where <span class="math inline">\(\mathbf{u} \sim \text{Uniform}(0, 1)\)</span>. The method leverages the special structure of the precision matrix and employs efficient eigendecomposition techniques to avoid explicit formation and inversion of the large precision matrix Q.</p>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="gmrf-copula" class="level2">
<h2 class="anchored" data-anchor-id="gmrf-copula">GMRF Copula</h2>
<p>Let <span class="math inline">\(\mathbf{X} = (X_1, X_2, \ldots, X_n)\)</span> be a multivariate random vector with marginal distribution functions <span class="math inline">\(F_i\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span> and dependence that is governed by a Gaussian copula. We create the vector</p>
<p>The matrix, Q, is defined as</p>
<p><span class="math display">\[
Q = Q_1 \otimes I + I \otimes Q_1,
\]</span></p>
<p>where <span class="math inline">\(Q_1\)</span> is the precision matrix of a standardized one-dimensional AR(1) process and <span class="math inline">\(\otimes\)</span> is the kronecker product.</p>
</section>
<section id="theory" class="level2">
<h2 class="anchored" data-anchor-id="theory">Theory</h2>
</section>
<section id="one-dimensional-ar1-matrix" class="level2">
<h2 class="anchored" data-anchor-id="one-dimensional-ar1-matrix">One-Dimensional AR(1) Matrix</h2>
<p>The core of our approach is based on the eigendecomposition of an AR(1) precision matrix, which forms the building block of our Matérn-like precision structure. For a one-dimensional AR(1) process with parameter <span class="math inline">\(\rho\)</span>, the precision matrix <span class="math inline">\(Q_1\)</span> has a tridiagonal structure:</p>
<p><span class="math display">\[
Q = \frac{1}{1 - \rho^2} \begin{bmatrix}
1 &amp; -\rho &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
-\rho &amp; 1+\rho^2 &amp; -\rho &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; -\rho &amp; 1+\rho^2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1+\rho^2 &amp; -\rho \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\rho &amp; 1 \\
\end{bmatrix}
\]</span></p>
</section>
<section id="matérn-like-precision-matrix" class="level2">
<h2 class="anchored" data-anchor-id="matérn-like-precision-matrix">Matérn-like Precision Matrix</h2>
<p>For two-dimensional spatial fields, we construct a Matérn-like precision matrix <span class="math inline">\(Q\)</span> using Kronecker products:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I + I \otimes Q_1
\]</span></p>
<p>where <span class="math inline">\(I\)</span> is the identity matrix and <span class="math inline">\(\otimes\)</span> denotes the Kronecker product The eigenvalues <span class="math inline">\((\lambda_k)\)</span> and eigenvectors <span class="math inline">\((v_k)\)</span> of <span class="math inline">\(Q_1\)</span> can be calculated numerically and used to evaluate the multivariate Gaussian density, letting us skip out on forming <span class="math inline">\(Q\)</span> entirely. This is due to the following theorem:</p>
</section>
<section id="eigendecomposition-of-kronecker-sums" class="level2">
<h2 class="anchored" data-anchor-id="eigendecomposition-of-kronecker-sums">Eigendecomposition of Kronecker Sums</h2>
<section id="theorem" class="level3">
<h3 class="anchored" data-anchor-id="theorem">Theorem</h3>
<p>Let <span class="math inline">\(A \in \mathbb{R}^{n \times n}\)</span> have eigenvalues <span class="math inline">\(\lambda_i\)</span>, <span class="math inline">\(i \in \{1, \ldots, n\}\)</span>, and let <span class="math inline">\(B \in \mathbb{R}^{m \times m}\)</span> have eigenvalues <span class="math inline">\(\mu_j\)</span>, <span class="math inline">\(j \in \{1, \ldots, m\}\)</span>. Then the Kronecker sum <span class="math inline">\(A \oplus B = (I_m \otimes A) + (B \otimes I_n)\)</span> has eigenvalues <span class="math inline">\(\lambda_i + \mu_j\)</span>, <span class="math inline">\(i \in \{1, \ldots, n\}, j \in \{1, \ldots, m\}\)</span>.</p>
<p>Moreover, if <span class="math inline">\(x_1, \ldots, x_p\)</span> are linearly independent right eigenvectors of <span class="math inline">\(A\)</span> corresponding to <span class="math inline">\(\lambda_1, \ldots, \lambda_p\)</span> (<span class="math inline">\(p \leq n\)</span>), and <span class="math inline">\(z_1, \ldots, z_q\)</span> are linearly independent right eigenvectors of <span class="math inline">\(B\)</span> corresponding to <span class="math inline">\(\mu_1, \ldots, \mu_q\)</span> (<span class="math inline">\(q \leq m\)</span>), then <span class="math inline">\(z_j \otimes x_i \in \mathbb{R}^{mn}\)</span> are linearly independent right eigenvectors of <span class="math inline">\(A \oplus B\)</span> corresponding to <span class="math inline">\(\lambda_i + \mu_j\)</span>, <span class="math inline">\(i \in \{1, \ldots, p\}, j \in \{1, \ldots, q\}\)</span>.</p>
</section>
<section id="discussion" class="level3">
<h3 class="anchored" data-anchor-id="discussion">Discussion</h3>
<p>This theorem provides a crucial insight that allows us to efficiently construct the eigendecomposition of the full precision matrix <span class="math inline">\(Q\)</span> for two-dimensional spatial fields by leveraging the eigendecomposition of the one-dimensional precision matrix <span class="math inline">\(Q_1\)</span>, avoiding the computationally intensive process of explicitly forming and inverting the large matrix <span class="math inline">\(Q\)</span>.</p>
<p>Furthermore, we can compute the log-density of an observation x directly by using just the eigenvalues and eigenvectors og <span class="math inline">\(Q_1\)</span>, thereby enabling efficient computation of the log-density of the multivariate normal distribution even for large spatial fields.</p>
</section>
</section>
<section id="example-calculating-eigenvalues-and-eigenvectors-for-q-using-q_1" class="level2">
<h2 class="anchored" data-anchor-id="example-calculating-eigenvalues-and-eigenvectors-for-q-using-q_1">Example: Calculating Eigenvalues and Eigenvectors for <span class="math inline">\(Q\)</span> Using <span class="math inline">\(Q_1\)</span></h2>
<p>To illustrate the application of Theorem 13.16, consider the one-dimensional precision matrix <span class="math inline">\(Q_1\)</span> with known eigendecomposition. Suppose <span class="math inline">\(Q_1\)</span> has eigenvalues <span class="math inline">\(\lambda_i\)</span> and corresponding eigenvectors <span class="math inline">\(v_i\)</span>. For a two-dimensional spatial field, we construct the Matérn-like precision matrix <span class="math inline">\(Q\)</span> using Kronecker products as follows:</p>
<p><span class="math display">\[
Q = Q_1 \otimes I + I \otimes Q_1,
\]</span></p>
<p>where <span class="math inline">\(I\)</span> is the identity matrix and <span class="math inline">\(\otimes\)</span> denotes the Kronecker product.</p>
<section id="eigenvalues" class="level3">
<h3 class="anchored" data-anchor-id="eigenvalues">Eigenvalues</h3>
<p>The eigenvalues of <span class="math inline">\(Q\)</span> can be determined from the eigenvalues of <span class="math inline">\(Q_1\)</span>. If <span class="math inline">\(Q_1\)</span> has eigenvalues <span class="math inline">\(\lambda_i\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>, then the eigenvalues of <span class="math inline">\(Q\)</span> are given by:</p>
<p><span class="math display">\[
\lambda_{ij} = \lambda_i + \lambda_j \quad \text{for} \quad i, j = 1, 2, \ldots, n.
\]</span></p>
</section>
<section id="eigenvectors" class="level3">
<h3 class="anchored" data-anchor-id="eigenvectors">Eigenvectors</h3>
<p>Similarly, the eigenvectors of <span class="math inline">\(Q\)</span> can be constructed from the eigenvectors of <span class="math inline">\(Q_1\)</span>. If <span class="math inline">\(v_i\)</span> and <span class="math inline">\(v_j\)</span> are eigenvectors of <span class="math inline">\(Q_1\)</span> corresponding to eigenvalues <span class="math inline">\(\lambda_i\)</span> and <span class="math inline">\(\lambda_j\)</span> respectively, then the eigenvectors of <span class="math inline">\(Q\)</span> are given by:</p>
<p><span class="math display">\[
v_{ij} = v_i \otimes v_j \quad \text{for} \quad i, j = 1, 2, \ldots, n.
\]</span></p>
<p>Here, <span class="math inline">\(v_{ij}\)</span> is the Kronecker product of <span class="math inline">\(v_i\)</span> and <span class="math inline">\(v_j\)</span>.</p>
<p>These relationships allow us to efficiently compute the eigendecomposition of the full precision matrix <span class="math inline">\(Q\)</span> using the eigendecomposition of the smaller matrix <span class="math inline">\(Q_1\)</span>, significantly reducing the computational complexity.</p>
</section>
</section>
<section id="efficient-density-calculation-using-eigendecomposition" class="level2">
<h2 class="anchored" data-anchor-id="efficient-density-calculation-using-eigendecomposition">Efficient Density Calculation Using Eigendecomposition</h2>
<p>Given the eigendecomposition of Q1, we can efficiently compute the multivariate normal density with respect to the precision matrix Q. Let <span class="math inline">\(\lambda_i\)</span> and <span class="math inline">\(v_i\)</span> be the eigenvalues and eigenvectors of Q1, respectively.</p>
<p>The log-density of a multivariate normal distribution with precision matrix Q is given by:</p>
<p><span class="math display">\[
\log p(x) = -\frac{1}{2} (n \log(2\pi) - \log|Q| + x^T Q x)
\]</span></p>
<p>where <span class="math inline">\(n\)</span> is the dimension of <span class="math inline">\(x\)</span>, <span class="math inline">\(|Q|\)</span> is the determinant of Q, and <span class="math inline">\(x^T Q x\)</span> is the quadratic form.</p>
<section id="log-determinant-calculation" class="level3">
<h3 class="anchored" data-anchor-id="log-determinant-calculation">Log-Determinant Calculation</h3>
<p>The log-determinant of Q can be computed efficiently using the eigenvalues of Q1:</p>
<p><span class="math display">\[
\log|Q| = \sum_{i=1}^d \sum_{j=1}^d \log(\lambda_i + \lambda_j)
\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the dimension of Q1.</p>
</section>
<section id="quadratic-form-calculation" class="level3">
<h3 class="anchored" data-anchor-id="quadratic-form-calculation">Quadratic Form Calculation</h3>
<p>First, we define the product of the eigenvector and the data vector <span class="math inline">\(x\)</span> as:</p>
<p><span class="math display">\[
y_{ij} = (v_i \otimes v_j)^T x,
\]</span></p>
<p>where <span class="math inline">\(v_i\)</span> and <span class="math inline">\(v_j\)</span> are the eigenvectors of <span class="math inline">\(Q_1\)</span> and <span class="math inline">\(\otimes\)</span> denotes the Kronecker product.</p>
<p>Next, we define the eigenvalue sum as:</p>
<p><span class="math display">\[
\mu_{ij} = \lambda_i + \lambda_j,
\]</span></p>
<p>where <span class="math inline">\(\lambda_i\)</span> and <span class="math inline">\(\lambda_j\)</span> are the eigenvalues of <span class="math inline">\(Q_1\)</span>. Using these definitions, the quadratic form can be expressed as:</p>
<p><span class="math display">\[
x^T Q x = \sum_{i=1}^d \sum_{j=1}^d \mu_{ij} y_{ij}^2.
\]</span></p>
<p>In this way, we calculate the quadratic form without having to form the matrix Q or its full set of eigenvectors or values.</p>
</section>
<section id="scaling-the-input-x" class="level3">
<h3 class="anchored" data-anchor-id="scaling-the-input-x">Scaling the Input x</h3>
<p>The input vector <span class="math inline">\(x = \Phi^{-1}(u)\)</span> has zero mean and unit marginal variance. Instead of scaling the precision matrix to have <span class="math inline">\((Q^{-1})_{ii} = 1\)</span>, we calculate the marginal standard deviations, <span class="math inline">\(\sigma_k\)</span>, implied by <span class="math inline">\(Q\)</span> using the eigenstructure of <span class="math inline">\(Q_1\)</span>, then scale the input vector <span class="math inline">\(x\)</span> using those standard deviations. First we compute the marginal standard deviations: <span class="math display">\[
\sigma_k = \sqrt{\sum_{i=1}^d \sum_{j=1}^d \frac{(v_i \otimes v_j)_k^2}{\lambda_i + \lambda_j}}
\]</span></p>
<p>where <span class="math inline">\((v_i \otimes v_j)_k\)</span> is the <span class="math inline">\(k\)</span>-th element of the Kronecker product <span class="math inline">\(v_i \otimes v_j\)</span>.</p>
</section>
</section>
<section id="algorithm-implementation" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-implementation">Algorithm Implementation</h2>
<p>The density calculation is implemented as follows:</p>
<ul>
<li>Compute the eigendecomposition of <span class="math inline">\(Q_1\)</span>.</li>
<li>Calculate the marginal standard deviations <span class="math inline">\(\sigma_k\)</span>.</li>
<li>For each observation <span class="math inline">\(x\)</span>:
<ol type="a">
<li>Standardize <span class="math inline">\(x\)</span> by element-wise multiplication with <span class="math inline">\(\sigma_k\)</span>.</li>
<li>Compute the log-determinant and quadratic form using the formulas above.</li>
<li>Combine the terms to get the log-density.</li>
</ol></li>
</ul>
<p>This approach avoids explicit formation and inversion of the full precision matrix Q, allowing for efficient computation even for large spatial fields. This method has been implemented in C++ code that can perform a full set of computations for a <span class="math inline">\(200\times 200\)</span> spatial grid (i.e.&nbsp;<span class="math inline">\(Q\)</span> would be <span class="math inline">\(40.000 \times 40.000\)</span>) in just over one second.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>